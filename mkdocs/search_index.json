{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to SCONE\n\n\nSCONE is a platform to \nbuild and run secure containers\n. Secure containers protect the confidentiality and integrity \nof containers by runing services inside Intel SGX enclaves. For example, we protect services against nosy administrators and hackers with root access that could otherwise just dump the main memory content or configuration files of services to get access to keys stored there. \n\n\nThe secure containers are compatible with Docker containers. SCONE uses Docker Swarm to run and orchestrate \napplications consisting of multiple containers running across multiple hosts. \nWe plan to support other container services - like Kubernetes and Ranger - at some later time.\n\n\nApplication-Oriented Security\n\n\nSCONE supports DevOps to protect the confidentiality and integrity of application even when running in clouds that\ncannot be (completely) trusted. Our approach is to encrypt - by default - all network communication, all files and all \nprocessing (by running inside of enclaves). To reduce the required resources, we support an opt-out approach that\npermits to drop certain protections. For example, a service that operates only on encrypted data might not need to be protected with SGX. \n\n\nEase of Use\n\n\nSCONE supports strong application-oriented security with a workflow like Docker, i.e., \nSCONE supports \nDockerfiles\n as well as extended Docker \nstack\n files. This simplifies the construction and operation of applications consisting of a set of containers. This fits in particular modern cloud-native applications consisting of  microservices and each microservice runs either in a standard or a secure container.\n\n\n\n\nDocumentation\n\n\n\n\n\n\nSCONE Background\n: we give a short introduction regarding the objectives and the problems addressed by SCONE.\n\n\n\n\n\n\nSCONE Host Setup\n: to run secure containers, \nwe need to configure each host to run a Linux SGX driver and also a (for convenience, a patched) Docker engine. \n\n\n\n\n\n\nSCONE SGX Toolchain\n: SCONE supports cross-compilers (C, C++, more to come soon) to compile and build \napplications for SGX enclaves.  \n\n\n\n\n\n\nSCONE Curated Container Images\n: we will support a set of secure container images to simplify the use of  \n\n\n\n\n\n\nSCONE Tutorial\n: we show how to compile simple example applications with the help of the SCONE SGX Toolchain.\n\n\n\n\n\n\nSCONE Dockerfile\n: we support the use of Dockerfiles to generate Docker images that contain services running inside of SGX enclaves (this requires a \npatched Docker Engine\n).\n\n\n\n\n\n\nSCONE Swarm\n: show how to setup a Docker Swarm usable for SCONE.\n\n\n\n\n\n\nSCONE Swarm Example\n: shows an example of how to start SCONE services on top of a Docker Swarm. \n\n\n\n\n\n\nPublications\n:  some of the technical aspects of SCONE have been published in scientific papers. \nWe provide a short summary of the papers and links to the pdfs. \n\n\n\n\n\n\nAuthor: Christof Fetzer, 2017",
            "title": "Introduction"
        },
        {
            "location": "/#welcome-to-scone",
            "text": "SCONE is a platform to  build and run secure containers . Secure containers protect the confidentiality and integrity \nof containers by runing services inside Intel SGX enclaves. For example, we protect services against nosy administrators and hackers with root access that could otherwise just dump the main memory content or configuration files of services to get access to keys stored there.   The secure containers are compatible with Docker containers. SCONE uses Docker Swarm to run and orchestrate \napplications consisting of multiple containers running across multiple hosts. \nWe plan to support other container services - like Kubernetes and Ranger - at some later time.",
            "title": "Welcome to SCONE"
        },
        {
            "location": "/#application-oriented-security",
            "text": "SCONE supports DevOps to protect the confidentiality and integrity of application even when running in clouds that\ncannot be (completely) trusted. Our approach is to encrypt - by default - all network communication, all files and all \nprocessing (by running inside of enclaves). To reduce the required resources, we support an opt-out approach that\npermits to drop certain protections. For example, a service that operates only on encrypted data might not need to be protected with SGX.",
            "title": "Application-Oriented Security"
        },
        {
            "location": "/#ease-of-use",
            "text": "SCONE supports strong application-oriented security with a workflow like Docker, i.e., \nSCONE supports  Dockerfiles  as well as extended Docker  stack  files. This simplifies the construction and operation of applications consisting of a set of containers. This fits in particular modern cloud-native applications consisting of  microservices and each microservice runs either in a standard or a secure container.",
            "title": "Ease of Use"
        },
        {
            "location": "/#documentation",
            "text": "SCONE Background : we give a short introduction regarding the objectives and the problems addressed by SCONE.    SCONE Host Setup : to run secure containers, \nwe need to configure each host to run a Linux SGX driver and also a (for convenience, a patched) Docker engine.     SCONE SGX Toolchain : SCONE supports cross-compilers (C, C++, more to come soon) to compile and build \napplications for SGX enclaves.      SCONE Curated Container Images : we will support a set of secure container images to simplify the use of      SCONE Tutorial : we show how to compile simple example applications with the help of the SCONE SGX Toolchain.    SCONE Dockerfile : we support the use of Dockerfiles to generate Docker images that contain services running inside of SGX enclaves (this requires a  patched Docker Engine ).    SCONE Swarm : show how to setup a Docker Swarm usable for SCONE.    SCONE Swarm Example : shows an example of how to start SCONE services on top of a Docker Swarm.     Publications :  some of the technical aspects of SCONE have been published in scientific papers. \nWe provide a short summary of the papers and links to the pdfs.     Author: Christof Fetzer, 2017",
            "title": "Documentation"
        },
        {
            "location": "/background/",
            "text": "SCONE Background\n\n\n\n\nApplication-oriented security\n. The objective of SCONE is to help service providers to build secure applications for public, private or hybrid clouds. This means that the focus of SCONE is on application-oriented security and not on the security of the underlying cloud system. Of course, SCONE-based applications benefit from strong security properties of the underlying cloud because this minimizes, for example, the attack surface of SCONE-based applications and by providing higher availability. SCONE helps to ensure the security of an application, i.e., the application's integrity and confidentiality, even if the security of the underlying cloud or system software would be compromised. The security of applications is ensured with the help of Intel SGX enclaves. \n\n\n\n\n\n\n\n\nEase of use\n. SCONE combines strong security with the ease of use of Docker. SCONE supports a workflow very similar to that of Docker. It supports the construction of applications consisting of multiple containers while ensuring end-to-end encryption between all application components in the sense that all network traffic, all files and even all computation is encrypted. A service provider can ensure the confidentiality and integrity of all application data. In particular, SCONE supports the construction of applications such that no higher privileged software like the operating system or the hypervisor, nor any system administrator with root access nor cold boot attacks can gain access to application data.\n\n\n\n\n\n\nProblem: Defender's Dilemma\n\n\nTraditionally, one ensures the security of an application by ensuring that the system software, i.e., the hypervisor, operating system and cloud software is trustworthy. This not only protects the integrity and confidentiality of the system data but also protects the security of the applications. A service provider running applications in the cloud must trust all system software and also all administrators who have root or physical access to these systems.\n\n\nFor an attacker it might be sufficient to exploit a single vulnerability in either the application or the system software to violate the application security. The problem of this approach is that the defenders must protect against the exploitation of every single vulnerability that might exist in the source code. A service provider might not have access to the source code of the system software that the cloud provider uses to operate the cloud. Even if the source code were available, this will typically be too large to be inspected. \n\n\nTo show how large this problem is, let's look at the number of lines of source code of common system software components. While lines of source code is not an ideal  indicator for the number of vulnerabilities, it gives some indication of the problem we are facing. Some security researchers state that given the current state of the art, only code with up to 10,000s of lines of code can be reasonably inspected. Just the system software itself - which all needs to be protected - contains millions of lines of code. This is orders of magnitudes more than we can reasonably expect to be able to inspect.\n\n\nSCONE runs on top of Linux - which contains millions of lines of code and is still growing in size with each release:\n\n\n\n\nLinux Lines of Code (StefanPohl, CC0, \noriginal\n}\n\n\nOpenStack is a popular open source software to manage clouds. OpenStack - despite being relatively young - has been growing dramatically over the years that it has already reached 5 million lines of code (including comments and blank lines):\n\n\n\n\nOpenStack Lines of Code (OpenHub \noriginal\n)\n\n\nTo manage containers, we need an engine like Docker. Docker is younger than OpenStack but has nevertheless reached already more than 180,000 lines of code:\n\n\n\n\nDocker Lines of Code (OpenHub \noriginal\n)\n\n\nCode complexity\n.There is no one-to-one correlation between lines of codes and bugs. Static analysis of open source code repositories indicates approximately 0.61 defects per 1,000 LOC. A recent analysis of Linux shows that, despite an increasing number of defects being fixed, there are always approximately 5,000 defects waiting to be fixed. Not all of these defects can, however, be exploited for security attacks. Another analysis found that approximately 500 security-relevant bugs were fixed in Linux over the past five years - bugs that had been in the kernel for five years before being discovered and fixed. Commercial code had a slightly higher defect density than open source projects. Hence, we need to expect vulnerabilities in commercial software too.\n\n\nSCONE Approach\n\n\nThe approach of SCONE is to reduce the code size by placing only the essential components of an application inside of enclaves. Our underlying assumption is that it is practically to difficult to split existing code base of a single process into component that run inside an enclave and components that run outside of an enclave. However, many modern applications - like cloud-native applications - are already split in several components running in separate address spaces. These components are typically microservices. \n\n\nOne can build even critical applications with the help of microservices. Not all microservices of an application need to run in enclaves to protect the application\u2019s integrity and confidentiality. For example, some services might only process encrypted data, like encrypted log data, and do not need to run in enclaves.  Also, the resource manager does not need to run in an enclave either. \n\n\nThe use of microservices supports horizontal scalability. This helps to cope with limited EPC (extended page cache) by spreading secure microservices across different CPUs.\n\n\nAuthor: Christof Fetzer, 2017",
            "title": "SCONE Background"
        },
        {
            "location": "/background/#scone-background",
            "text": "Application-oriented security . The objective of SCONE is to help service providers to build secure applications for public, private or hybrid clouds. This means that the focus of SCONE is on application-oriented security and not on the security of the underlying cloud system. Of course, SCONE-based applications benefit from strong security properties of the underlying cloud because this minimizes, for example, the attack surface of SCONE-based applications and by providing higher availability. SCONE helps to ensure the security of an application, i.e., the application's integrity and confidentiality, even if the security of the underlying cloud or system software would be compromised. The security of applications is ensured with the help of Intel SGX enclaves.      Ease of use . SCONE combines strong security with the ease of use of Docker. SCONE supports a workflow very similar to that of Docker. It supports the construction of applications consisting of multiple containers while ensuring end-to-end encryption between all application components in the sense that all network traffic, all files and even all computation is encrypted. A service provider can ensure the confidentiality and integrity of all application data. In particular, SCONE supports the construction of applications such that no higher privileged software like the operating system or the hypervisor, nor any system administrator with root access nor cold boot attacks can gain access to application data.",
            "title": "SCONE Background"
        },
        {
            "location": "/background/#problem-defenders-dilemma",
            "text": "Traditionally, one ensures the security of an application by ensuring that the system software, i.e., the hypervisor, operating system and cloud software is trustworthy. This not only protects the integrity and confidentiality of the system data but also protects the security of the applications. A service provider running applications in the cloud must trust all system software and also all administrators who have root or physical access to these systems.  For an attacker it might be sufficient to exploit a single vulnerability in either the application or the system software to violate the application security. The problem of this approach is that the defenders must protect against the exploitation of every single vulnerability that might exist in the source code. A service provider might not have access to the source code of the system software that the cloud provider uses to operate the cloud. Even if the source code were available, this will typically be too large to be inspected.   To show how large this problem is, let's look at the number of lines of source code of common system software components. While lines of source code is not an ideal  indicator for the number of vulnerabilities, it gives some indication of the problem we are facing. Some security researchers state that given the current state of the art, only code with up to 10,000s of lines of code can be reasonably inspected. Just the system software itself - which all needs to be protected - contains millions of lines of code. This is orders of magnitudes more than we can reasonably expect to be able to inspect.  SCONE runs on top of Linux - which contains millions of lines of code and is still growing in size with each release:   Linux Lines of Code (StefanPohl, CC0,  original }  OpenStack is a popular open source software to manage clouds. OpenStack - despite being relatively young - has been growing dramatically over the years that it has already reached 5 million lines of code (including comments and blank lines):   OpenStack Lines of Code (OpenHub  original )  To manage containers, we need an engine like Docker. Docker is younger than OpenStack but has nevertheless reached already more than 180,000 lines of code:   Docker Lines of Code (OpenHub  original )  Code complexity .There is no one-to-one correlation between lines of codes and bugs. Static analysis of open source code repositories indicates approximately 0.61 defects per 1,000 LOC. A recent analysis of Linux shows that, despite an increasing number of defects being fixed, there are always approximately 5,000 defects waiting to be fixed. Not all of these defects can, however, be exploited for security attacks. Another analysis found that approximately 500 security-relevant bugs were fixed in Linux over the past five years - bugs that had been in the kernel for five years before being discovered and fixed. Commercial code had a slightly higher defect density than open source projects. Hence, we need to expect vulnerabilities in commercial software too.",
            "title": "Problem: Defender's Dilemma"
        },
        {
            "location": "/background/#scone-approach",
            "text": "The approach of SCONE is to reduce the code size by placing only the essential components of an application inside of enclaves. Our underlying assumption is that it is practically to difficult to split existing code base of a single process into component that run inside an enclave and components that run outside of an enclave. However, many modern applications - like cloud-native applications - are already split in several components running in separate address spaces. These components are typically microservices.   One can build even critical applications with the help of microservices. Not all microservices of an application need to run in enclaves to protect the application\u2019s integrity and confidentiality. For example, some services might only process encrypted data, like encrypted log data, and do not need to run in enclaves.  Also, the resource manager does not need to run in an enclave either.   The use of microservices supports horizontal scalability. This helps to cope with limited EPC (extended page cache) by spreading secure microservices across different CPUs.  Author: Christof Fetzer, 2017",
            "title": "SCONE Approach"
        },
        {
            "location": "/SCONE_HOSTINSTALLER_README/",
            "text": "SCONE: Host Installation Guide\n\n\nThis documentation describes how \n\n\n\n\nto set up a host such that it can run SCONE secure containers, i.e., containers in which processes run inside of SGX enclaves,\n\n\n\n\nThe installation script\n\n\n\n\n\n\ninstalls the Intel SGX drive (if it is not yet installed), \n\n\n\n\n\n\ninstalls a patched docker engine, and\n\n\n\n\n\n\nstarts/joins a docker swarm - if requested by command line options.\n\n\n\n\n\n\nPrerequisite\n:  We assume that you have Ubuntu 16.04LTS (or later) installed. \n\n\nSCONE Documentation\n\n\nTo read more about our SCONE secure container framework, read the online\ndocumentation at \nhttps://sconedocs.github.io/\n.\n\n\nFor offline reading, please ensure that docker is installed and then execute the following:\n\n\ndocker pull sconecuratedimages/sconedocu\ndocker run -d -p 8080:80  sconecuratedimages/sconedocu\nopen http://127.0.0.1:8080\n\n\n\n\nPatched Docker Engine\n\n\nFor an container to be able to use SGX, it has to have access to a device (/dev/isgx). This device permits the container to talk to the SGX driver, e.g., to create SGX enclaves. Some docker commands (like \ndocker run\n) support an option --device (i.e., \n--device /dev/isgx\n) which allows us to give a container access to the SGX device. We need to point out that some docker commands (like \ndocker build\n) do, however, not support the device option. Therefore, we maintain and install a slightly patched docker engine (i.e., a variant of moby): this engine ensures that each container has access to the SGX device (/dev/isgx).  With the help of this patched engine, we can use Dockerfiles to generate container images (see this \nTutorial\n).\n\n\nInstallation\n\n\nTo install all necessary software to run secure containers on a host, clone the script:\n\n\ngit clone https://github.com/christoffetzer/SCONE_HOSTINSTALLER.git\n\n\n\n\nensure that you are permitted to execute sudo and execute the following command:\n\n\ncd SCONE_HOSTINSTALLER\n\n\n\n\nIn case you have already a docker engine installed, executing the\n\ninstallation script will remove the installed docker engine first.\n\n\nInstalling the Swarm Manager\n\n\nEach Docker Swarm requires at least one manager. The installation script\ncan set up the first manager via:\n\n\n./install.sh --manager\n\n\n\n\nThe IP address of this manager is used for the nodes of the swarm to find each other. The above script will output how to install other nodes and 'OK' on success:\n\n\n# to install another machine and add as a manager, execute\n./install.sh --token SWMTKN-1-2f98skv0z2vdhnyw9liwbqtgocts6comdr81o6e3u6kd9olbrc-48zv9ho4f3poid4d34767nucj 192.168.4.101:2377\n# to install another machine and add as worker, execute\n./install.sh --token SWMTKN-1-2f98skv0z2vdhnyw9liwbqtgocts6comdr81o6e3u6kd9olbrc-91z9bxu0exqli87elwasyjj5w 192.168.4.101:2377\nOK\n\n\n\n\nIf you do not remember the tokens, you can output the token by executing the following script (on a manager node):\n\n\n./show-tokens.sh \n\n\n\n\nInstalling a Swarm Worker\n\n\nTo install a new worker node, execute something like this (use the correct worker token - which is printed during the master installation):\n\n\n./install.sh --token SWMTKN-1-2f98skv0z2vdhnyw9liwbqtgocts6comdr81o6e3u6kd9olbrc-91z9bxu0exqli87elwasyjj5w 192.168.4.101:2377\n\n\n\n\nInstalling another Manager Node\n\n\nIn a small installation, we might only have one manager. However, in\nlarger installation it makes sense to have 3 or 5 manager nodes.\nTo install a new manager node, execute something like this (use the manager token):\n\n\n./install.sh --token SWMTKN-1-2f98skv0z2vdhnyw9liwbqtgocts6comdr81o6e3u6kd9olbrc-48zv9ho4f3poid4d34767nucj 192.168.4.101:2377\n\n\n\n\nThe install.sh script outputs 'OK' on success.\n\n\nChecking your Installation\n\n\nTo test the installation, one can run a simple hello-world container:\n\n\nsudo docker run hello-world\n\n\n\n\nFuture Work\n\n\n\n\nwe plan to support hosts managed by Ubuntu MaaS to simplify the process of installing Docker and DockerSwarm. \nWe plan to provide a preconfigured SCONE host images for MaaS - as soon as custom MaaS images are supported (again).\n\n\n\n\nAuthor: Christof Fetzer, 2017",
            "title": "SCONE Host Setup"
        },
        {
            "location": "/SCONE_HOSTINSTALLER_README/#scone-host-installation-guide",
            "text": "This documentation describes how    to set up a host such that it can run SCONE secure containers, i.e., containers in which processes run inside of SGX enclaves,   The installation script    installs the Intel SGX drive (if it is not yet installed),     installs a patched docker engine, and    starts/joins a docker swarm - if requested by command line options.    Prerequisite :  We assume that you have Ubuntu 16.04LTS (or later) installed.",
            "title": "SCONE: Host Installation Guide"
        },
        {
            "location": "/SCONE_HOSTINSTALLER_README/#scone-documentation",
            "text": "To read more about our SCONE secure container framework, read the online\ndocumentation at  https://sconedocs.github.io/ .  For offline reading, please ensure that docker is installed and then execute the following:  docker pull sconecuratedimages/sconedocu\ndocker run -d -p 8080:80  sconecuratedimages/sconedocu\nopen http://127.0.0.1:8080",
            "title": "SCONE Documentation"
        },
        {
            "location": "/SCONE_HOSTINSTALLER_README/#patched-docker-engine",
            "text": "For an container to be able to use SGX, it has to have access to a device (/dev/isgx). This device permits the container to talk to the SGX driver, e.g., to create SGX enclaves. Some docker commands (like  docker run ) support an option --device (i.e.,  --device /dev/isgx ) which allows us to give a container access to the SGX device. We need to point out that some docker commands (like  docker build ) do, however, not support the device option. Therefore, we maintain and install a slightly patched docker engine (i.e., a variant of moby): this engine ensures that each container has access to the SGX device (/dev/isgx).  With the help of this patched engine, we can use Dockerfiles to generate container images (see this  Tutorial ).",
            "title": "Patched Docker Engine"
        },
        {
            "location": "/SCONE_HOSTINSTALLER_README/#installation",
            "text": "To install all necessary software to run secure containers on a host, clone the script:  git clone https://github.com/christoffetzer/SCONE_HOSTINSTALLER.git  ensure that you are permitted to execute sudo and execute the following command:  cd SCONE_HOSTINSTALLER  In case you have already a docker engine installed, executing the installation script will remove the installed docker engine first.  Installing the Swarm Manager  Each Docker Swarm requires at least one manager. The installation script\ncan set up the first manager via:  ./install.sh --manager  The IP address of this manager is used for the nodes of the swarm to find each other. The above script will output how to install other nodes and 'OK' on success:  # to install another machine and add as a manager, execute\n./install.sh --token SWMTKN-1-2f98skv0z2vdhnyw9liwbqtgocts6comdr81o6e3u6kd9olbrc-48zv9ho4f3poid4d34767nucj 192.168.4.101:2377\n# to install another machine and add as worker, execute\n./install.sh --token SWMTKN-1-2f98skv0z2vdhnyw9liwbqtgocts6comdr81o6e3u6kd9olbrc-91z9bxu0exqli87elwasyjj5w 192.168.4.101:2377\nOK  If you do not remember the tokens, you can output the token by executing the following script (on a manager node):  ./show-tokens.sh   Installing a Swarm Worker  To install a new worker node, execute something like this (use the correct worker token - which is printed during the master installation):  ./install.sh --token SWMTKN-1-2f98skv0z2vdhnyw9liwbqtgocts6comdr81o6e3u6kd9olbrc-91z9bxu0exqli87elwasyjj5w 192.168.4.101:2377  Installing another Manager Node  In a small installation, we might only have one manager. However, in\nlarger installation it makes sense to have 3 or 5 manager nodes.\nTo install a new manager node, execute something like this (use the manager token):  ./install.sh --token SWMTKN-1-2f98skv0z2vdhnyw9liwbqtgocts6comdr81o6e3u6kd9olbrc-48zv9ho4f3poid4d34767nucj 192.168.4.101:2377  The install.sh script outputs 'OK' on success.",
            "title": "Installation"
        },
        {
            "location": "/SCONE_HOSTINSTALLER_README/#checking-your-installation",
            "text": "To test the installation, one can run a simple hello-world container:  sudo docker run hello-world",
            "title": "Checking your Installation"
        },
        {
            "location": "/SCONE_HOSTINSTALLER_README/#future-work",
            "text": "we plan to support hosts managed by Ubuntu MaaS to simplify the process of installing Docker and DockerSwarm. \nWe plan to provide a preconfigured SCONE host images for MaaS - as soon as custom MaaS images are supported (again).   Author: Christof Fetzer, 2017",
            "title": "Future Work"
        },
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/",
            "text": "SCONE SGX Toolchain\n\n\nSCONE comes with cross-compilers for popular languages: C, C++, GO, Rust as well as Fortran.\nThe objective of these cross compilers are to compile applications - generally without source code changes - such\nthat they can run inside of SGX enclaves.\n\n\nTo simplify the use of these cross-compilers, SCONE maintains curated container image that includes these cross-compilers.\n\n\nUsing the C/C++ compiler container\n\n\nHow to use the compiler:\n\n\n\n\n\n\nuse this as a base image and build your programs inside of a container (see \nDockerfiles\n), or \n\n\n\n\n\n\nmap volumes such that the compiler can compile files living outside the container (see \nSCONE Tutorial\n). This is probably only practical for small projects.\n\n\n\n\n\n\nExample\n\n\nOne can use the compiler by giving it access to external files as follows:\n\n\ndocker run --rm --device=/dev/isgx -v \"$PWD\":/usr/src/myapp -w /usr/src/myapp sgxmusl:draft sgxmusl-hw-async-gcc /usr/src/myapp/myapp.c\n\n\n\n\nSee our \nhello world\n in Section \nSCONE Tutorial\n. This is kind of awkward and hence, we\nprovide a simpler version with the help of \nDockerfiles\n. \n\n\nCompiler variants\n\n\nThe SCONE SGX toolchain supports multiple C and C++ cross compilers variants. In future, we will probably only support a single variant. Hence, we recommend the use of the cross compiler as shown in \nDockerfiles\n.\n\n\nCurrently, the SCONE SGX toolchain supports the following variants of C and C++ cross compilers:\n\n\n\n\n\n\nhw-async\n: generates enclaved programs that use the SCONE asynchronous system call interface, i.e., threads do not exit the enclave to execute a system call. For a technical explanation see [SCONE paper in OSDI2016]. \n\n\n\n\n\n\nhw-shielded\n: this variant based on \nhw-async\n that additionally supports transparent file protection (i.e., transparent encryption von files) and transparent socket protection (i.e., encryption via TLS).  \n\n\n\n\n\n\nhw-sync\n [measurements only]: this variant uses synchronous system calls, i.e., threads leave the enclave to perform a system call. We maintain this variant for measurement purposes only and we recommend to use \nhw-async\n instead.\n\n\n\n\n\n\nsim\n [SCONE development only]: does not need SGX CPU extension and can, for example, be used to develop on machines without SGX support. This is not 100% compatible to \nhw-async\n (yet) and hence, do not use this variant - unless you are aware that the limitations are ok for you.\n\n\n\n\n\n\nsim-shielded\n [SCONE development only]: this variant based on \nsim\n that additionally supports transparent file protection (i.e., transparent encryption von files) and transparent socket protection (i.e., encryption via TLS).  \n\n\n\n\n\n\nDebugger support\n\n\nWe also support \ngdb\n to debug applications running inside of enclaves. \n\n\nFuture work\n\n\n\n\ndescribe the use of the debugger.\n\n\n\n\nAuthor: Christof Fetzer, 2017",
            "title": "SCONE SGX toolchain"
        },
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/#scone-sgx-toolchain",
            "text": "SCONE comes with cross-compilers for popular languages: C, C++, GO, Rust as well as Fortran.\nThe objective of these cross compilers are to compile applications - generally without source code changes - such\nthat they can run inside of SGX enclaves.  To simplify the use of these cross-compilers, SCONE maintains curated container image that includes these cross-compilers.",
            "title": "SCONE SGX Toolchain"
        },
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/#using-the-cc-compiler-container",
            "text": "How to use the compiler:    use this as a base image and build your programs inside of a container (see  Dockerfiles ), or     map volumes such that the compiler can compile files living outside the container (see  SCONE Tutorial ). This is probably only practical for small projects.",
            "title": "Using the C/C++ compiler container"
        },
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/#example",
            "text": "One can use the compiler by giving it access to external files as follows:  docker run --rm --device=/dev/isgx -v \"$PWD\":/usr/src/myapp -w /usr/src/myapp sgxmusl:draft sgxmusl-hw-async-gcc /usr/src/myapp/myapp.c  See our  hello world  in Section  SCONE Tutorial . This is kind of awkward and hence, we\nprovide a simpler version with the help of  Dockerfiles .",
            "title": "Example"
        },
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/#compiler-variants",
            "text": "The SCONE SGX toolchain supports multiple C and C++ cross compilers variants. In future, we will probably only support a single variant. Hence, we recommend the use of the cross compiler as shown in  Dockerfiles .  Currently, the SCONE SGX toolchain supports the following variants of C and C++ cross compilers:    hw-async : generates enclaved programs that use the SCONE asynchronous system call interface, i.e., threads do not exit the enclave to execute a system call. For a technical explanation see [SCONE paper in OSDI2016].     hw-shielded : this variant based on  hw-async  that additionally supports transparent file protection (i.e., transparent encryption von files) and transparent socket protection (i.e., encryption via TLS).      hw-sync  [measurements only]: this variant uses synchronous system calls, i.e., threads leave the enclave to perform a system call. We maintain this variant for measurement purposes only and we recommend to use  hw-async  instead.    sim  [SCONE development only]: does not need SGX CPU extension and can, for example, be used to develop on machines without SGX support. This is not 100% compatible to  hw-async  (yet) and hence, do not use this variant - unless you are aware that the limitations are ok for you.    sim-shielded  [SCONE development only]: this variant based on  sim  that additionally supports transparent file protection (i.e., transparent encryption von files) and transparent socket protection (i.e., encryption via TLS).",
            "title": "Compiler variants"
        },
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/#debugger-support",
            "text": "We also support  gdb  to debug applications running inside of enclaves.",
            "title": "Debugger support"
        },
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/#future-work",
            "text": "describe the use of the debugger.   Author: Christof Fetzer, 2017",
            "title": "Future work"
        },
        {
            "location": "/SCONE_Curated_Images/",
            "text": "SCONE Curated Images\n\n\nWe provide a set of curated SCONE container images on a (private) repositories on Docker hub:\n\n\n\n\nsconecuratedimages/sconedocu\n: contains containers related to our SCONE documentation \n\n\nsconecuratedimages/crosscompilers\n: contains container images of the SCONE cross compilers \n\n\nsconecuratedimages/tutorial\n: contains containers related to our SCONE tutorial \n\n\n\n\nScone Documentation\n\n\nTo run a local copy of the SCONE documentation, just perform the following steps:\n\n\ndocker pull sconecuratedimages/sconedocu\ndocker run -d -p 8080:80  sconecuratedimages/sconedocu\n\n\n\n\nView the documentation in your browser at http://127.0.0.1:8080 .\nOn a MAC, just type:\n\n\nopen http://127.0.0.1:8080\n\n\n\n\nto view this docu.\n\n\nLogin in\n\n\nAccess to some SCONE images is still restricted. First, get access\nto the images by sending email to scone.containers@gmail.com. \nSecond, log into to docker hub via:\n\n\ndocker login\n\n\n\n\nbefore you pull any of the curated images.\n\n\nScone Cross-Compilers\n\n\nTo run a local copy of the SCONE cross compilers, just pull the appropriate image on your computer.\n\n\nIn case you do not have SGX CPU extension / no SGX driver installed on your computer,\nyou can use our simulation environment. This runs the SCONE software but provides \nno protection\nof the confidentiality nor integrity\n of your application:\n\n\nsudo docker pull sconecuratedimages/crosscompilers:gcc-sim\n\n\n\n\nTo install our standard scone C / C++ cross compiler, just perform the following\nsteps.\n\n\nsudo docker pull sconecuratedimages/crosscompilers\n\n\n\n\nScone Hello World\n\n\nYou can pull the following image:\n\n\nsudo docker pull sconecuratedimages/helloworld\n\n\n\n\nand run the helloworld program inside of an enclave via\n\n\n> sudo docker run --device=/dev/isgx sconecuratedimages/helloworld\nHello World\n\n\n\n\nthis will fail, in case you do not provide the container with the sgx device:\n\n\n> sudo docker run sconecuratedimages/helloworld\nerror opening sgx device: No such file or directory\n\n\n\n\nNote, if you installed the modified Docker Engine that we provide, a container gets\nby default access to device \n/dev/isgx\n, i.e., in this case no error would occur.\n\n\nAuthor: Christof Fetzer, 2017",
            "title": "SCONE Curated Images"
        },
        {
            "location": "/SCONE_Curated_Images/#scone-curated-images",
            "text": "We provide a set of curated SCONE container images on a (private) repositories on Docker hub:   sconecuratedimages/sconedocu : contains containers related to our SCONE documentation   sconecuratedimages/crosscompilers : contains container images of the SCONE cross compilers   sconecuratedimages/tutorial : contains containers related to our SCONE tutorial",
            "title": "SCONE Curated Images"
        },
        {
            "location": "/SCONE_Curated_Images/#scone-documentation",
            "text": "To run a local copy of the SCONE documentation, just perform the following steps:  docker pull sconecuratedimages/sconedocu\ndocker run -d -p 8080:80  sconecuratedimages/sconedocu  View the documentation in your browser at http://127.0.0.1:8080 .\nOn a MAC, just type:  open http://127.0.0.1:8080  to view this docu.",
            "title": "Scone Documentation"
        },
        {
            "location": "/SCONE_Curated_Images/#login-in",
            "text": "Access to some SCONE images is still restricted. First, get access\nto the images by sending email to scone.containers@gmail.com. \nSecond, log into to docker hub via:  docker login  before you pull any of the curated images.",
            "title": "Login in"
        },
        {
            "location": "/SCONE_Curated_Images/#scone-cross-compilers",
            "text": "To run a local copy of the SCONE cross compilers, just pull the appropriate image on your computer.  In case you do not have SGX CPU extension / no SGX driver installed on your computer,\nyou can use our simulation environment. This runs the SCONE software but provides  no protection\nof the confidentiality nor integrity  of your application:  sudo docker pull sconecuratedimages/crosscompilers:gcc-sim  To install our standard scone C / C++ cross compiler, just perform the following\nsteps.  sudo docker pull sconecuratedimages/crosscompilers",
            "title": "Scone Cross-Compilers"
        },
        {
            "location": "/SCONE_Curated_Images/#scone-hello-world",
            "text": "You can pull the following image:  sudo docker pull sconecuratedimages/helloworld  and run the helloworld program inside of an enclave via  > sudo docker run --device=/dev/isgx sconecuratedimages/helloworld\nHello World  this will fail, in case you do not provide the container with the sgx device:  > sudo docker run sconecuratedimages/helloworld\nerror opening sgx device: No such file or directory  Note, if you installed the modified Docker Engine that we provide, a container gets\nby default access to device  /dev/isgx , i.e., in this case no error would occur.  Author: Christof Fetzer, 2017",
            "title": "Scone Hello World"
        },
        {
            "location": "/SCONE_TUTORIAL/",
            "text": "SCONE Tutorial\n\n\nPrerequisites\n\n\nEnsure that the sgx driver is installed\n\n\n> ls /dev/isgx \n/dev/isgx\n\n\n\n\nIf the driver is not installed, read Section \nSCONE Host Setup\n to learn how to install the SGX driver.\n\n\nInstall sgxmusl cross compiler image\n\n\nEnsure that you installed the sgxmusl:draft container image:\n\n\n> docker image ls sconecuratedimages/crosscompilers\nREPOSITORY                          TAG                 IMAGE ID            CREATED             SIZE\nsconecuratedimages/crosscompilers   gcc-sim             e5cabb3682d6        17 hours ago        1.18 GB\nsconecuratedimages/crosscompilers   gcc-sync            a4768b000fcc        18 hours ago        1.18 GB\n\n\n\n\nIf the cross compiler image is not yet installed, read Section \nSCONE Curated Container Images\n to learn how to install the SCONE cross compiler image.\n\n\nInstall the tutorial\n\n\nClone the tutorial: \n\n\ngit clone https://github.com/christoffetzer/SCONE_TUTORIAL.git\n\n\n\n\nNative Hello World\n\n\nEnsure that \nhello world\n runs natively on your machine:\n\n\ncd SCONE_TUTORIAL/HelloWorld/\ngcc hello_world.c  -o native_hello_world\n./native_hello_world\nHello World\n\n\n\n\nSIM Hello World\n\n\nNow, let us compile \nhello world\n with the help of a cross compiler image that creates binaries that include all SCONE software \nbut the services run actually outside of enclave. We call this variant \nsim\n and made available in image \nsconecuratedimages/crosscompilers:gcc-sim\n\nthat you can pull from docker hub.\n\n\nThe sim variant simplifies debugging. \nsim\n is, however, not 100% identical with the \nasync\n branch (i.e., the recommended branch to run applications inside of enclaves).\nHence, debugging using \nsim\n might not be possible for all bugs. \n\n\nsudo docker run --rm -v \"$PWD\":/usr/src/myapp -w /usr/src/myapp sconecuratedimages/crosscompilers:gcc-sim sgxmusl-sim-gcc /usr/src/myapp/hello_world.c  -o sim_hello_world\n./sim_hello_world\nHello World\n\n\n\n\nNote that the generated executable, i.e., \nsim_hello_world\n, will only run on Linux. \n\n\nSGX ASYNC Hello World\n\n\nThe default cross compiler variant that runs \nhello world\n inside of an enclave is \nsgxmusl-hw-async-gcc\n and you can find this in container \nsconecuratedimages/crosscompilers\n. \nThis variant requires access to the SGX device. \nIn Linux, the SGX device is made available as \n/dev/isgx\n and we can give the cross compiler inside of an container access via option \n--device=/dev/isgx\n:\n\n\nsudo docker run --rm --device=/dev/isgx -v \"$PWD\":/usr/src/myapp -w /usr/src/myapp sconecuratedimages/crosscompilers sgxmusl-hw-async-gcc /usr/src/myapp/hello_world.c  -o sgx_hello_world\n./sgx_hello_world\nHello World\n\n\n\n\nThe compilation as well as the hello world program will fail in case you do not have the appropriate driver installed.\n\n\nRun STRACE\n\n\nLets see how we can trace the program. Say, you have compile the program as shown above. After that you enter a cross compiler container and strace hello world as follows:\n\n\nsudo docker run --cap-add SYS_PTRACE -it --rm --device=/dev/isgx -v \"$PWD\":/usr/src/myapp -w /usr/src/myapp sconecuratedimages/crosscompilers bash\nstrace  -f /usr/src/myapp/sgx_sync_hello_world\n\n\n\n\nRun ShellScript\n\n\nAuthor: Christof Fetzer, April 2017",
            "title": "SCONE Tutorial"
        },
        {
            "location": "/SCONE_TUTORIAL/#scone-tutorial",
            "text": "",
            "title": "SCONE Tutorial"
        },
        {
            "location": "/SCONE_TUTORIAL/#prerequisites",
            "text": "Ensure that the sgx driver is installed  > ls /dev/isgx \n/dev/isgx  If the driver is not installed, read Section  SCONE Host Setup  to learn how to install the SGX driver.  Install sgxmusl cross compiler image  Ensure that you installed the sgxmusl:draft container image:  > docker image ls sconecuratedimages/crosscompilers\nREPOSITORY                          TAG                 IMAGE ID            CREATED             SIZE\nsconecuratedimages/crosscompilers   gcc-sim             e5cabb3682d6        17 hours ago        1.18 GB\nsconecuratedimages/crosscompilers   gcc-sync            a4768b000fcc        18 hours ago        1.18 GB  If the cross compiler image is not yet installed, read Section  SCONE Curated Container Images  to learn how to install the SCONE cross compiler image.",
            "title": "Prerequisites"
        },
        {
            "location": "/SCONE_TUTORIAL/#install-the-tutorial",
            "text": "Clone the tutorial:   git clone https://github.com/christoffetzer/SCONE_TUTORIAL.git",
            "title": "Install the tutorial"
        },
        {
            "location": "/SCONE_TUTORIAL/#native-hello-world",
            "text": "Ensure that  hello world  runs natively on your machine:  cd SCONE_TUTORIAL/HelloWorld/\ngcc hello_world.c  -o native_hello_world\n./native_hello_world\nHello World",
            "title": "Native Hello World"
        },
        {
            "location": "/SCONE_TUTORIAL/#sim-hello-world",
            "text": "Now, let us compile  hello world  with the help of a cross compiler image that creates binaries that include all SCONE software \nbut the services run actually outside of enclave. We call this variant  sim  and made available in image  sconecuratedimages/crosscompilers:gcc-sim \nthat you can pull from docker hub.  The sim variant simplifies debugging.  sim  is, however, not 100% identical with the  async  branch (i.e., the recommended branch to run applications inside of enclaves).\nHence, debugging using  sim  might not be possible for all bugs.   sudo docker run --rm -v \"$PWD\":/usr/src/myapp -w /usr/src/myapp sconecuratedimages/crosscompilers:gcc-sim sgxmusl-sim-gcc /usr/src/myapp/hello_world.c  -o sim_hello_world\n./sim_hello_world\nHello World  Note that the generated executable, i.e.,  sim_hello_world , will only run on Linux.",
            "title": "SIM Hello World"
        },
        {
            "location": "/SCONE_TUTORIAL/#sgx-async-hello-world",
            "text": "The default cross compiler variant that runs  hello world  inside of an enclave is  sgxmusl-hw-async-gcc  and you can find this in container  sconecuratedimages/crosscompilers . \nThis variant requires access to the SGX device. \nIn Linux, the SGX device is made available as  /dev/isgx  and we can give the cross compiler inside of an container access via option  --device=/dev/isgx :  sudo docker run --rm --device=/dev/isgx -v \"$PWD\":/usr/src/myapp -w /usr/src/myapp sconecuratedimages/crosscompilers sgxmusl-hw-async-gcc /usr/src/myapp/hello_world.c  -o sgx_hello_world\n./sgx_hello_world\nHello World  The compilation as well as the hello world program will fail in case you do not have the appropriate driver installed.",
            "title": "SGX ASYNC Hello World"
        },
        {
            "location": "/SCONE_TUTORIAL/#run-strace",
            "text": "Lets see how we can trace the program. Say, you have compile the program as shown above. After that you enter a cross compiler container and strace hello world as follows:  sudo docker run --cap-add SYS_PTRACE -it --rm --device=/dev/isgx -v \"$PWD\":/usr/src/myapp -w /usr/src/myapp sconecuratedimages/crosscompilers bash\nstrace  -f /usr/src/myapp/sgx_sync_hello_world",
            "title": "Run STRACE"
        },
        {
            "location": "/SCONE_TUTORIAL/#run-shellscript",
            "text": "Author: Christof Fetzer, April 2017",
            "title": "Run ShellScript"
        },
        {
            "location": "/SCONE_GENERATE_IMAGE/",
            "text": "Generating Container Image with SCONE\n\n\nWe show how to generate a Docker image that contains our \nhello world\n running inside of an enclave and pushing this to docker hub. We show this \n\n\nPrerequisites\n\n\nCheck that all prerequisites from \nSCONE Tutorial\n are satisfied. \nClone the SCONE_TUTORIAL before you start creating a \nhello world\n image.\n\n\nGenerate HelloWorld image\n\n\nWe generate a \nhello world\n container image. \n\n\ncd SCONE_TUTORIAL/CreateImage\n\n\n\n\nYou can either execute all step manually by copy&pasting all instructions or you can just execute\n\n\ndocker login\nsudo ./Dockerfile.sh\n\n\n\n\nand watch the outputs.\n\n\nPlease change the image name to a repository on docker hub to which you can write:\n\n\nexport TAG=\"latest\"\nexport IMAGE_NAME=\"sconecuratedimages/helloworld\"\n\n\n\n\nWe generate container and compile hello world inside of this container with the help of our standard SCONE cross compiler:\n\n\n\nCONTAINER_ID=`docker run -d -it --device=/dev/isgx  -v $(pwd):/mnt sconecuratedimages/crosscompilers bash -c \"\nset -e\nsgxmusl-hw-async-gcc /mnt/hello_world.c  -o /usr/local/bin/sgx_hello_world\n\"`\n\n\n\n\nNote that above will fail if you do not have access to the SGX device \n/dev/isgx\n.\n\n\nTurn the container into an image:\n\n\nIMAGE_ID=$(docker commit -p -c 'CMD sgx_hello_world' $CONTAINER_ID $IMAGE_NAME:$TAG)\n\n\n\n\nYou can run this image by executing:\n\n\nsudo docker run --device=/dev/isgx $IMAGE_NAME:$TAG\n\n\n\n\nYou can push this image to Docker. However, ensure that you first login to docker:\n\n\nsudo docker login\n\n\n\n\nbefore you push the image to docker hub:\n\n\nsudo docker push $IMAGE_NAME:$TAG\n\n\n\n\nNote: this will fail in case you do not have the permission to push to this repository. \n\n\nAuthor: Christof Fetzer, April 2017",
            "title": "SCONE Create Image"
        },
        {
            "location": "/SCONE_GENERATE_IMAGE/#generating-container-image-with-scone",
            "text": "We show how to generate a Docker image that contains our  hello world  running inside of an enclave and pushing this to docker hub. We show this",
            "title": "Generating Container Image with SCONE"
        },
        {
            "location": "/SCONE_GENERATE_IMAGE/#prerequisites",
            "text": "Check that all prerequisites from  SCONE Tutorial  are satisfied. \nClone the SCONE_TUTORIAL before you start creating a  hello world  image.",
            "title": "Prerequisites"
        },
        {
            "location": "/SCONE_GENERATE_IMAGE/#generate-helloworld-image",
            "text": "We generate a  hello world  container image.   cd SCONE_TUTORIAL/CreateImage  You can either execute all step manually by copy&pasting all instructions or you can just execute  docker login\nsudo ./Dockerfile.sh  and watch the outputs.  Please change the image name to a repository on docker hub to which you can write:  export TAG=\"latest\"\nexport IMAGE_NAME=\"sconecuratedimages/helloworld\"  We generate container and compile hello world inside of this container with the help of our standard SCONE cross compiler:  \nCONTAINER_ID=`docker run -d -it --device=/dev/isgx  -v $(pwd):/mnt sconecuratedimages/crosscompilers bash -c \"\nset -e\nsgxmusl-hw-async-gcc /mnt/hello_world.c  -o /usr/local/bin/sgx_hello_world\n\"`  Note that above will fail if you do not have access to the SGX device  /dev/isgx .  Turn the container into an image:  IMAGE_ID=$(docker commit -p -c 'CMD sgx_hello_world' $CONTAINER_ID $IMAGE_NAME:$TAG)  You can run this image by executing:  sudo docker run --device=/dev/isgx $IMAGE_NAME:$TAG  You can push this image to Docker. However, ensure that you first login to docker:  sudo docker login  before you push the image to docker hub:  sudo docker push $IMAGE_NAME:$TAG  Note: this will fail in case you do not have the permission to push to this repository.   Author: Christof Fetzer, April 2017",
            "title": "Generate HelloWorld image"
        },
        {
            "location": "/SCONE_Dockerfile/",
            "text": "Dockerfile\n\n\nWe show how to generate a Docker image with the help of a Dockerfile.\n\n\nPrerequisites\n\n\nEnsure that the sgx driver is installed\n\n\n> ls /dev/isgx \n/dev/isgx\n\n\n\n\nIf the driver is not installed, read Section \nSCONE Host Setup\n to learn how to install the SGX driver.\n\n\nEnsure that the patched docker engine is installed\n\n\nWe need \ndocker build\n in this example. This command does not permit to map devices in the newly created containers. Hence, we provide a patched Docker engine \nSCONE Host Setup\n.\n\n\nInstall the tutorial\n\n\nClone the tutorial: \n\n\ngit clone https://github.com/christoffetzer/SCONE_TUTORIAL.git\n\n\n\n\nAccess to SCONE Curated Images\n\n\nRight now, access to the curated images is still restricted. Please, send email to scone.containers@gmail.com to request access.\n\n\nGenerate HelloAgain image\n\n\nWe generate a \nhello again\n container image. \n\n\ncd SCONE_TUTORIAL/Dockerfile\n\n\n\n\nThe Dockerfile looks, feels like a standard docker image:\n\n\nFROM sconecuratedimages/crosscompilers:sgxmusl-hw-async-gcc\n\nMAINTAINER Christof Fetzer \"christof.fetzer@gmail.com\"\n\nRUN mkdir /hello\n\nCOPY hello_again.c /hello/\n\nRUN cd /hello && gcc hello_again.c -o again\n\nCMD [\"/hello/again\"]\n\n\n\n\nYou can either execute all step manually (see below) or you can just execute\n\n\ndocker login\n./generate.sh\n\n\n\n\nand watch the outputs. The push of the image should fail since you should not have the access rights to push the image to Docker hub.\n\n\nWe define the image name and tag that we want to generate:\n\n\nexport TAG=\"again\"\nexport FULLTAG=\"sconecuratedimages/helloworld:$TAG\"\n\n\n\n\nWe build the image:\n\n\ndocker build --pull -t $FULLTAG .\n\n\n\n\nWe push it to docker hub (will fail unless you have the right to push \n$FULLTAG\n):\n\n\ndocker push $FULLTAG\n\n\n\n\nPlease change the image name to a repository on docker hub to which you can write:\n\n\nexport TAG=\"latest\"\nexport IMAGE_NAME=\"sconecuratedimages/helloAgain\"\n\n\n\n\nAuthor: Christof Fetzer, 2017",
            "title": "SCONE Dockerfile"
        },
        {
            "location": "/SCONE_Dockerfile/#dockerfile",
            "text": "We show how to generate a Docker image with the help of a Dockerfile.",
            "title": "Dockerfile"
        },
        {
            "location": "/SCONE_Dockerfile/#prerequisites",
            "text": "Ensure that the sgx driver is installed  > ls /dev/isgx \n/dev/isgx  If the driver is not installed, read Section  SCONE Host Setup  to learn how to install the SGX driver.  Ensure that the patched docker engine is installed  We need  docker build  in this example. This command does not permit to map devices in the newly created containers. Hence, we provide a patched Docker engine  SCONE Host Setup .  Install the tutorial  Clone the tutorial:   git clone https://github.com/christoffetzer/SCONE_TUTORIAL.git  Access to SCONE Curated Images  Right now, access to the curated images is still restricted. Please, send email to scone.containers@gmail.com to request access.",
            "title": "Prerequisites"
        },
        {
            "location": "/SCONE_Dockerfile/#generate-helloagain-image",
            "text": "We generate a  hello again  container image.   cd SCONE_TUTORIAL/Dockerfile  The Dockerfile looks, feels like a standard docker image:  FROM sconecuratedimages/crosscompilers:sgxmusl-hw-async-gcc\n\nMAINTAINER Christof Fetzer \"christof.fetzer@gmail.com\"\n\nRUN mkdir /hello\n\nCOPY hello_again.c /hello/\n\nRUN cd /hello && gcc hello_again.c -o again\n\nCMD [\"/hello/again\"]  You can either execute all step manually (see below) or you can just execute  docker login\n./generate.sh  and watch the outputs. The push of the image should fail since you should not have the access rights to push the image to Docker hub.  We define the image name and tag that we want to generate:  export TAG=\"again\"\nexport FULLTAG=\"sconecuratedimages/helloworld:$TAG\"  We build the image:  docker build --pull -t $FULLTAG .  We push it to docker hub (will fail unless you have the right to push  $FULLTAG ):  docker push $FULLTAG  Please change the image name to a repository on docker hub to which you can write:  export TAG=\"latest\"\nexport IMAGE_NAME=\"sconecuratedimages/helloAgain\"  Author: Christof Fetzer, 2017",
            "title": "Generate HelloAgain image"
        },
        {
            "location": "/SCONE_Swarm/",
            "text": "SCONE SWARM\n\n\nInstallation\n\n\nOur \nSCONE Host Setup\n script will typically set up a docker swarm. You can skip this section, if you have already a swarm running. \n\n\nTo manually set up a Docker swarm, log into designated manage node and execute:\n\n\nexport MANAGER_IP=`hostname --ip-address`\ndocker swarm init --advertise-addr $MANAGER_IP\n\n\n\n\nWe determine the address of the swarm manager and the token to join the swarm as follows\n\n\nexport manager_addr=`docker info --format '{{(index .Swarm.RemoteManagers 0).Addr}}'`\nexport token=`docker swarm join-token -q worker`\necho export token=$token\necho export manager_addr=$manager_addr\n\n\n\n\nOn each node that should join the swarm, ensure that you installed our patched Docker engine (which makes the isgx device available to all containers).\n\n\nAdd a new node to the swarm by setting \n$token\n  and \n$manager_addr\n to the values determined above and\nexecute on the new node:\n\n\ndocker swarm join --token $token $manager_addr\n\n\n\n\nSetting Node Labels\n\n\nDocker Swarm supports the labeling of nodes. In our case, we define a label \n\"sgx\"\n that permits us to determine if a node supports sgx and what version of sgx. \n\n\nWe define the following node labels:\n\n\n\n\n\n\nsgx == \"0\" iff the node does not support sgx\n\n\n\n\n\n\nsgx == \"1\" iff the node supports sgx version 1\n\n\n\n\n\n\nsgx == \"2\" iff the node supports sgx version 2 (which is not yet available)\n\n\n\n\n\n\nTo assign a label, we need to figure out the node ID. An easy way to do so, is via the following command:\n\n\n> docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS\n91a1vvex4dgozfrzy1y136gmg *   alice               Ready               Active              Leader\nocwyg135npgpsrpe2ncuw542x     beatrix             Ready               Active              \n\n\n\n\n\nOne can now manually update a label as follows:\n\n\n> docker node update --label-add sgx=\"1\" 91a1vvex4dgozfrzy1y136gmg\n91a1vvex4dgozfrzy1y136gmg\n\n\n\n\nFor large clusters, we can automate the labeling\nas described in the next subsection.\n\n\nAssign labels to all nodes\n\n\nDocker swarm keeps listing nodes nodes that are down - even if the host running the node has in meantime rejoined as a new node.\n\n\nTo purge all down nodes, execute the following:\n\n\ndocker node rm $(docker node ls -q)\n\n\n\n\nAssuming that all nodes in your swarm support sgx, we assign SGX label \"1\" to all (remaining) nodes:\n\n\nexport nodes=$(docker node ls -q)\nfor node in $nodes ; do\n    docker node update --label-add sgx=\"1\" $node\ndone\n\n\n\n\nWe can check that all sgx labels are \"1\" by executing the following:\n\n\ndocker inspect --format '{{(index  .Spec.Labels \"sgx\")}}' $nodes\n\n\n\n\nAuthor: Christof Fetzer, 2017",
            "title": "SCONE Swarm"
        },
        {
            "location": "/SCONE_Swarm/#scone-swarm",
            "text": "",
            "title": "SCONE SWARM"
        },
        {
            "location": "/SCONE_Swarm/#installation",
            "text": "Our  SCONE Host Setup  script will typically set up a docker swarm. You can skip this section, if you have already a swarm running.   To manually set up a Docker swarm, log into designated manage node and execute:  export MANAGER_IP=`hostname --ip-address`\ndocker swarm init --advertise-addr $MANAGER_IP  We determine the address of the swarm manager and the token to join the swarm as follows  export manager_addr=`docker info --format '{{(index .Swarm.RemoteManagers 0).Addr}}'`\nexport token=`docker swarm join-token -q worker`\necho export token=$token\necho export manager_addr=$manager_addr  On each node that should join the swarm, ensure that you installed our patched Docker engine (which makes the isgx device available to all containers).  Add a new node to the swarm by setting  $token   and  $manager_addr  to the values determined above and\nexecute on the new node:  docker swarm join --token $token $manager_addr",
            "title": "Installation"
        },
        {
            "location": "/SCONE_Swarm/#setting-node-labels",
            "text": "Docker Swarm supports the labeling of nodes. In our case, we define a label  \"sgx\"  that permits us to determine if a node supports sgx and what version of sgx.   We define the following node labels:    sgx == \"0\" iff the node does not support sgx    sgx == \"1\" iff the node supports sgx version 1    sgx == \"2\" iff the node supports sgx version 2 (which is not yet available)    To assign a label, we need to figure out the node ID. An easy way to do so, is via the following command:  > docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS\n91a1vvex4dgozfrzy1y136gmg *   alice               Ready               Active              Leader\nocwyg135npgpsrpe2ncuw542x     beatrix             Ready               Active                One can now manually update a label as follows:  > docker node update --label-add sgx=\"1\" 91a1vvex4dgozfrzy1y136gmg\n91a1vvex4dgozfrzy1y136gmg  For large clusters, we can automate the labeling\nas described in the next subsection.",
            "title": "Setting Node Labels"
        },
        {
            "location": "/SCONE_Swarm/#assign-labels-to-all-nodes",
            "text": "Docker swarm keeps listing nodes nodes that are down - even if the host running the node has in meantime rejoined as a new node.  To purge all down nodes, execute the following:  docker node rm $(docker node ls -q)  Assuming that all nodes in your swarm support sgx, we assign SGX label \"1\" to all (remaining) nodes:  export nodes=$(docker node ls -q)\nfor node in $nodes ; do\n    docker node update --label-add sgx=\"1\" $node\ndone  We can check that all sgx labels are \"1\" by executing the following:  docker inspect --format '{{(index  .Spec.Labels \"sgx\")}}' $nodes  Author: Christof Fetzer, 2017",
            "title": "Assign labels to all nodes"
        },
        {
            "location": "/SCONE_Swarm_Example/",
            "text": "Starting a SCONE Application on a Swarm\n\n\n docker service create --name \"ha\" --detach=true -p 80:80 -p 443:443 --constraint 'node.labels.sgx != 0'  sconecuratedimages/nginx:noshielding\n\n\n\n\nIf this fails, you get a status as follows: \n\n\n> docker service ps ha\nID                  NAME                IMAGE                      NODE                DESIRED STATE       CURRENT STATE           ERROR                       PORTS\nf65id6ow5n6w        ha.1                sconecuratedimages/nginx   beatrix             Ready               Ready 1 second ago                                  \njt6wj5e3lso4         \\_ ha.1            sconecuratedimages/nginx   beatrix             Shutdown            Failed 3 seconds ago    \"task: non-zero exit (1)\"   \nsspou3mcis8m         \\_ ha.1            sconecuratedimages/nginx   beatrix             Shutdown            Failed 9 seconds ago    \"task: non-zero exit (1)\"   \np3bw780pu63b         \\_ ha.1            sconecuratedimages/nginx   beatrix             Shutdown            Failed 15 seconds ago   \"task: non-zero exit (1)\"   \n75zjsesil5k4         \\_ ha.1            sconecuratedimages/nginx   beatrix             Shutdown            Failed 22 seconds ago   \"task: non-zero exit (1)\"   \n\n\n\n\nReasons for failures might be that you do have access to the sgx device. Did you indeed install the patched docker version? Did you indeed label the nodes correctly?\n\n\nIn case service correctly starts up, you will see a status like this: \n\n\n> docker service ps ha\ndocker service ps nginx_service\nID                  NAME       IMAGE                                  NODE                DESIRED STATE       CURRENT STATE            ERROR                              PORTS\nx2xq1c3aede7        ha.1       sconecuratedimages/nginx:noshielding   alice               Running             Running 8 minutes ago         \n\n\n\n\nStopping the service\n\n\nStop the service via:\n\n\ndocker service rm ha\n\n\n\n\nScalable Fault-Tolerant Service\n\n\nWe start a nginx service this time with the scontain.com website. We start two replicas, each\nof these need to run on  a SGXv1 machines:\n\n\n> docker service create --name \"sconeweb\" --detach=true  --publish 80:80 --publish 443:443 --constraint 'node.labels.sgx == 1'  --replicas=2 sconecuratedimages/sconetainer:noshielding\n\n\n\n\nIf the image is not available on one of the nodes, you might see the following status:\n\n\n> docker service ps sconeweb\nID                  NAME                IMAGE                                        NODE                DESIRED STATE       CURRENT STATE          ERROR                              PORTS\no79714pw2fpn        sconeweb.1          sconecuratedimages/sconetainer:noshielding   alice               Running             Running 4 hours ago                                       \nt0byepte0fzj         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago   \"No such image: sconecuratedim\u2026\"   \nmg4xdq868syq         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago   \"No such image: sconecuratedim\u2026\"   \nry1pqen9jgan         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago   \"No such image: sconecuratedim\u2026\"   \nq05ti7gkxc7r         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago   \"No such image: sconecuratedim\u2026\"   \nzxj74inh2zdf        sconeweb.2          sconecuratedimages/sconetainer:noshielding   alice               Running             Running 4 hours ago                                       \n\n\n\n\nFor the next steps, make sure that all nodes have access to image \nsconecuratedimages/sconetainer:noshielding\n \nby executing on all nodes:\n\n\ndocker pull sconecuratedimages/sconetainer:noshielding\n\n\n\n\nDraining a node\n\n\nTo be able to drain all containers from a node, we need to figure out the node's id. We can do this manually by executing the following command:\n\n\n> docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS\n91a1vvex4dgozfrzy1y136gmg *   alice               Ready               Active              Leader\njhrayos9ylu02egwvkxpqtbwb     beatrix             Ready               Active              \n\n\n\n\nYou can now take node \nalice\n out of service by executing:\n\n\n> docker node update --availability drain 91a1vvex4dgozfrzy1y136gmg\n\n\n\n\nThe status of service might now be as follows:\n\n\n> docker service ps sconeweb\nID                  NAME                IMAGE                                        NODE                DESIRED STATE       CURRENT STATE            ERROR                              PORTS\nqaekdszhm8ua        sconeweb.1          sconecuratedimages/sconetainer:noshielding   beatrix             Running             Running 5 seconds ago                                       \no79714pw2fpn         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   alice               Shutdown            Shutdown 7 seconds ago                                      \nt0byepte0fzj         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago     \"No such image: sconecuratedim\u2026\"   \nmg4xdq868syq         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago     \"No such image: sconecuratedim\u2026\"   \nry1pqen9jgan         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago     \"No such image: sconecuratedim\u2026\"   \nkheb76bceupz        sconeweb.2          sconecuratedimages/sconetainer:noshielding   beatrix             Running             Running 6 seconds ago                                       \nzxj74inh2zdf         \\_ sconeweb.2      sconecuratedimages/sconetainer:noshielding   alice               Shutdown            Shutdown 7 seconds ago       \n\n\n\n\nTo put the node back in service, execute:\n\n\ndocker node update --availability active 91a1vvex4dgozfrzy1y136gmg\n\n\n\n\nRunning your own registry\n\n\nIn the above example, we have seen that we had to pull images explicitly from docker hub on each node. This is of course not satisfactory solution. Instead, we should run our own local registry with a copy of the image. You can do this as follows: \n\n\ndocker service create --name registry --detach=true  --publish 5000:5000 --publish 443:443 --replicas=1 registry\n\n\n\n\nNow the our local registry is running, we need to pull the images that we want to store in this registry first. Then, we tag the pulled image with the name of our local registry:\n\n\ndocker pull sconecuratedimages/sconetainer:noshielding\ndocker tag sconecuratedimages/sconetainer:noshielding localhost:5000/sconetainer\n\n\n\n\nWe then push the tagged image to our local registry:\n\n\ndocker push localhost:5000/sconetainer\n\n\n\n\nWe can now create a service using the image stored in the local registry:\n\n\ndocker service create --name \"ha\" --detach=true  --publish 9080:80 --publish 9443:9443 --constraint 'node.labels.sgx != 0'  --replicas=2 localhost:5000/sconetainer\n\n\n\n\nUpdating the image of a service\n\n\nSay, there is a new version of the sconetainer image available. We can update this image in our local registry\nas follows:\n\n\ndocker pull sconecuratedimages/sconetainer:noshielding\ndocker tag sconecuratedimages/sconetainer:noshielding localhost:5000/sconetainer\ndocker push localhost:5000/sconetainer\n\n\n\n\nWe can now update the service as follows:\n\n\ndocker service update --image  localhost:5000/sconetainer ha\n\n\n\n\nAuthor: Christof Fetzer,  2017",
            "title": "SCONE Swarm Example"
        },
        {
            "location": "/SCONE_Swarm_Example/#starting-a-scone-application-on-a-swarm",
            "text": "docker service create --name \"ha\" --detach=true -p 80:80 -p 443:443 --constraint 'node.labels.sgx != 0'  sconecuratedimages/nginx:noshielding  If this fails, you get a status as follows:   > docker service ps ha\nID                  NAME                IMAGE                      NODE                DESIRED STATE       CURRENT STATE           ERROR                       PORTS\nf65id6ow5n6w        ha.1                sconecuratedimages/nginx   beatrix             Ready               Ready 1 second ago                                  \njt6wj5e3lso4         \\_ ha.1            sconecuratedimages/nginx   beatrix             Shutdown            Failed 3 seconds ago    \"task: non-zero exit (1)\"   \nsspou3mcis8m         \\_ ha.1            sconecuratedimages/nginx   beatrix             Shutdown            Failed 9 seconds ago    \"task: non-zero exit (1)\"   \np3bw780pu63b         \\_ ha.1            sconecuratedimages/nginx   beatrix             Shutdown            Failed 15 seconds ago   \"task: non-zero exit (1)\"   \n75zjsesil5k4         \\_ ha.1            sconecuratedimages/nginx   beatrix             Shutdown            Failed 22 seconds ago   \"task: non-zero exit (1)\"     Reasons for failures might be that you do have access to the sgx device. Did you indeed install the patched docker version? Did you indeed label the nodes correctly?  In case service correctly starts up, you will see a status like this:   > docker service ps ha\ndocker service ps nginx_service\nID                  NAME       IMAGE                                  NODE                DESIRED STATE       CURRENT STATE            ERROR                              PORTS\nx2xq1c3aede7        ha.1       sconecuratedimages/nginx:noshielding   alice               Running             Running 8 minutes ago",
            "title": "Starting a SCONE Application on a Swarm"
        },
        {
            "location": "/SCONE_Swarm_Example/#stopping-the-service",
            "text": "Stop the service via:  docker service rm ha",
            "title": "Stopping the service"
        },
        {
            "location": "/SCONE_Swarm_Example/#scalable-fault-tolerant-service",
            "text": "We start a nginx service this time with the scontain.com website. We start two replicas, each\nof these need to run on  a SGXv1 machines:  > docker service create --name \"sconeweb\" --detach=true  --publish 80:80 --publish 443:443 --constraint 'node.labels.sgx == 1'  --replicas=2 sconecuratedimages/sconetainer:noshielding  If the image is not available on one of the nodes, you might see the following status:  > docker service ps sconeweb\nID                  NAME                IMAGE                                        NODE                DESIRED STATE       CURRENT STATE          ERROR                              PORTS\no79714pw2fpn        sconeweb.1          sconecuratedimages/sconetainer:noshielding   alice               Running             Running 4 hours ago                                       \nt0byepte0fzj         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago   \"No such image: sconecuratedim\u2026\"   \nmg4xdq868syq         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago   \"No such image: sconecuratedim\u2026\"   \nry1pqen9jgan         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago   \"No such image: sconecuratedim\u2026\"   \nq05ti7gkxc7r         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago   \"No such image: sconecuratedim\u2026\"   \nzxj74inh2zdf        sconeweb.2          sconecuratedimages/sconetainer:noshielding   alice               Running             Running 4 hours ago                                         For the next steps, make sure that all nodes have access to image  sconecuratedimages/sconetainer:noshielding  \nby executing on all nodes:  docker pull sconecuratedimages/sconetainer:noshielding",
            "title": "Scalable Fault-Tolerant Service"
        },
        {
            "location": "/SCONE_Swarm_Example/#draining-a-node",
            "text": "To be able to drain all containers from a node, we need to figure out the node's id. We can do this manually by executing the following command:  > docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS\n91a1vvex4dgozfrzy1y136gmg *   alice               Ready               Active              Leader\njhrayos9ylu02egwvkxpqtbwb     beatrix             Ready               Active                You can now take node  alice  out of service by executing:  > docker node update --availability drain 91a1vvex4dgozfrzy1y136gmg  The status of service might now be as follows:  > docker service ps sconeweb\nID                  NAME                IMAGE                                        NODE                DESIRED STATE       CURRENT STATE            ERROR                              PORTS\nqaekdszhm8ua        sconeweb.1          sconecuratedimages/sconetainer:noshielding   beatrix             Running             Running 5 seconds ago                                       \no79714pw2fpn         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   alice               Shutdown            Shutdown 7 seconds ago                                      \nt0byepte0fzj         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago     \"No such image: sconecuratedim\u2026\"   \nmg4xdq868syq         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago     \"No such image: sconecuratedim\u2026\"   \nry1pqen9jgan         \\_ sconeweb.1      sconecuratedimages/sconetainer:noshielding   beatrix             Shutdown            Rejected 4 hours ago     \"No such image: sconecuratedim\u2026\"   \nkheb76bceupz        sconeweb.2          sconecuratedimages/sconetainer:noshielding   beatrix             Running             Running 6 seconds ago                                       \nzxj74inh2zdf         \\_ sconeweb.2      sconecuratedimages/sconetainer:noshielding   alice               Shutdown            Shutdown 7 seconds ago         To put the node back in service, execute:  docker node update --availability active 91a1vvex4dgozfrzy1y136gmg",
            "title": "Draining a node"
        },
        {
            "location": "/SCONE_Swarm_Example/#running-your-own-registry",
            "text": "In the above example, we have seen that we had to pull images explicitly from docker hub on each node. This is of course not satisfactory solution. Instead, we should run our own local registry with a copy of the image. You can do this as follows:   docker service create --name registry --detach=true  --publish 5000:5000 --publish 443:443 --replicas=1 registry  Now the our local registry is running, we need to pull the images that we want to store in this registry first. Then, we tag the pulled image with the name of our local registry:  docker pull sconecuratedimages/sconetainer:noshielding\ndocker tag sconecuratedimages/sconetainer:noshielding localhost:5000/sconetainer  We then push the tagged image to our local registry:  docker push localhost:5000/sconetainer  We can now create a service using the image stored in the local registry:  docker service create --name \"ha\" --detach=true  --publish 9080:80 --publish 9443:9443 --constraint 'node.labels.sgx != 0'  --replicas=2 localhost:5000/sconetainer",
            "title": "Running your own registry"
        },
        {
            "location": "/SCONE_Swarm_Example/#updating-the-image-of-a-service",
            "text": "Say, there is a new version of the sconetainer image available. We can update this image in our local registry\nas follows:  docker pull sconecuratedimages/sconetainer:noshielding\ndocker tag sconecuratedimages/sconetainer:noshielding localhost:5000/sconetainer\ndocker push localhost:5000/sconetainer  We can now update the service as follows:  docker service update --image  localhost:5000/sconetainer ha  Author: Christof Fetzer,  2017",
            "title": "Updating the image of a service"
        },
        {
            "location": "/SCONE_Publications/",
            "text": "SCONE Related Publications\n\n\nSCONE: Secure Linux Containers with Intel SGX, USENIX, OSDI 2016\n\n\nThis paper describes how we support unmodified applications inside of enclaves. The focus is on our asynchronous system\n call interface.\n\n\n\n\n\n\nAuthors\n:  Sergei Arnautov, Bohdan Trach, Franz Gregor, Thomas Knauth, Andr\u00e9 Martin, Christian Priebe, Joshua Lind, Divya Muthukumaran, Daniel O'Keeffe, Mark L Stillwell, David Goltzsche, Dave Eyers, R\u00fcdiger Kapitza, Peter Pietzuch, Christof Fetzer\n\n\n\n\n\n\nMedia\n: \npdf\n, \nslides\n\n\naudio\n\n\n\n\n\n\nAbstract\n:  In multi-tenant environments, Linux containers managed by Docker or Kubernetes have a lower resource footprint, faster startup times, and higher I/O performance compared to virtual machines (VMs) on hypervisors. Yet their weaker isolation guarantees, enforced through software kernel mechanisms, make it easier for attackers to compromise the confidentiality and integrity of application data within containers.\nWe describe SCONE, a secure container mechanism for Docker that uses the SGX trusted execution support of Intel CPUs to protect container processes from outside attacks. The design of SCONE leads to (i) a small trusted computing base (TCB) and (ii) a low performance overhead: SCONE offers a secure C standard library interface that transparently encrypts/decrypts I/O data; to reduce the performance impact of thread synchronization and system calls within SGX enclaves, SCONE supports user-level threading and asynchronous system calls. Our evaluation shows that it protects unmodified applications with SGX, achieving 0.6x\u20131.2x of native throughput.\n\n\n\n\n\n\n SGXBounds: Memory Safety for Shielded Execution, EuroSys 2017\n\n\nTo protect the code running inside of an enclave, we implemented a novel bounds checker for enclaves. While we had expected\n to just be able to use MPX, we had to realized that MPX does not perform that well inside of enclaves. For details regarding\n the overheads,  please see this paper. \nThis won the best paper award of EuroSys 2017.\n\n\n\n\n\n\nAuthors\n: D. Kuvaiskii, O. Oleksenko, S. Arnautov, B. Trach, P. Bhatotia, P. Felber, C. Fetzer \n\n\n\n\n\n\nMedia\n: \npdf\n \n\n\n\n\n\n\nAbstract\n: Shielded execution based on Intel SGX provides strong security guarantees for legacy applications running on untrusted platforms. However, memory safety attacks such as Heartbleed can render the confidentiality and integrity properties of shielded execution completely ineffective. To prevent these attacks, the state-of-the-art memory-safety approaches can be used in the context of shielded execution. In this work, we first showcase that two prominent software- and hardware-based defenses, AddressSanitizer and Intel MPX respectively, are impractical for shielded execution due to high performance and memory overheads. This motivated our design of SGXBounds -- an efficient memory-safety approach for shielded execution exploiting the architectural features of Intel SGX. Our design is based on a simple combination of tagged pointers and compact memory layout. We implemented SGXBounds based on the LLVM compiler framework targeting unmodified multithreaded applications. Our evaluation using Phoenix, PARSEC, and RIPE benchmark suites shows that SGXBounds has performance and memory overheads of 18% and 0.1% respectively, while providing security guarantees similar to AddressSanitizer and Intel MPX. We have obtained similar results with four real-world case studies: SQLite, Memcached, Apache, and Nginx.\n\n\n\n\n\n\n FFQ: A Fast Single-Producer/Multiple-Consumer Concurrent FIFO Queue, IPDPS 2017\n\n\nThis paper describes our new lock-free queue for our asynchronous system calls.\n\n\n\n\n\n\nAuthors\n: Sergei Arnautov, Pascal Felber, Christof Fetzer and Bohdan Trach\n\n\n\n\n\n\nMedia\n: \nsorry, not yet available\n \n\n\n\n\n\n\nAbstract\n:  With the spreading of multi-core architectures, operating systems and applications are becoming increasingly more concurrent and their scalability is often limited by the primitives used to synchronize the different hardware threads. In this paper, we address the problem of how to optimize the throughput of a system with multiple producer and consumer threads. Such applications typically synchronize their threads via multi- producer/multi-consumer FIFO queues, but existing solutions have poor scalability, as we could observe when designing a secure application framework that requires high-throughput communication between many concurrent threads. In our target system, however, the items enqueued by different producers do not necessarily need to be FIFO ordered. Hence, we propose a fast FIFO queue, FFQ, that aims at maximizing throughput by specializing the algorithm for single-producer/multiple-consumer settings: each producer has its own queue from which multiple consumers can concurrently dequeue. Furthermore, while we pro- vide a wait-free interface for producers, we limit ourselves to lock-free consumers to eliminate the need for helping. We also propose a multi-producer variant to show which synchronization operations we were able to remove by focusing on a single producer variant. Our evaluation analyses the performance using micro- benchmarks and compares our results with other state-of-the-art solutions: FFQ exhibits excellent performance and scalability.\n\n\n\n\n\n\nAuthor: Christof Fetzer, 2017",
            "title": "SCONE Publications"
        },
        {
            "location": "/SCONE_Publications/#scone-related-publications",
            "text": "SCONE: Secure Linux Containers with Intel SGX, USENIX, OSDI 2016  This paper describes how we support unmodified applications inside of enclaves. The focus is on our asynchronous system\n call interface.    Authors :  Sergei Arnautov, Bohdan Trach, Franz Gregor, Thomas Knauth, Andr\u00e9 Martin, Christian Priebe, Joshua Lind, Divya Muthukumaran, Daniel O'Keeffe, Mark L Stillwell, David Goltzsche, Dave Eyers, R\u00fcdiger Kapitza, Peter Pietzuch, Christof Fetzer    Media :  pdf ,  slides  audio    Abstract :  In multi-tenant environments, Linux containers managed by Docker or Kubernetes have a lower resource footprint, faster startup times, and higher I/O performance compared to virtual machines (VMs) on hypervisors. Yet their weaker isolation guarantees, enforced through software kernel mechanisms, make it easier for attackers to compromise the confidentiality and integrity of application data within containers.\nWe describe SCONE, a secure container mechanism for Docker that uses the SGX trusted execution support of Intel CPUs to protect container processes from outside attacks. The design of SCONE leads to (i) a small trusted computing base (TCB) and (ii) a low performance overhead: SCONE offers a secure C standard library interface that transparently encrypts/decrypts I/O data; to reduce the performance impact of thread synchronization and system calls within SGX enclaves, SCONE supports user-level threading and asynchronous system calls. Our evaluation shows that it protects unmodified applications with SGX, achieving 0.6x\u20131.2x of native throughput.     SGXBounds: Memory Safety for Shielded Execution, EuroSys 2017  To protect the code running inside of an enclave, we implemented a novel bounds checker for enclaves. While we had expected\n to just be able to use MPX, we had to realized that MPX does not perform that well inside of enclaves. For details regarding\n the overheads,  please see this paper.  This won the best paper award of EuroSys 2017.    Authors : D. Kuvaiskii, O. Oleksenko, S. Arnautov, B. Trach, P. Bhatotia, P. Felber, C. Fetzer     Media :  pdf      Abstract : Shielded execution based on Intel SGX provides strong security guarantees for legacy applications running on untrusted platforms. However, memory safety attacks such as Heartbleed can render the confidentiality and integrity properties of shielded execution completely ineffective. To prevent these attacks, the state-of-the-art memory-safety approaches can be used in the context of shielded execution. In this work, we first showcase that two prominent software- and hardware-based defenses, AddressSanitizer and Intel MPX respectively, are impractical for shielded execution due to high performance and memory overheads. This motivated our design of SGXBounds -- an efficient memory-safety approach for shielded execution exploiting the architectural features of Intel SGX. Our design is based on a simple combination of tagged pointers and compact memory layout. We implemented SGXBounds based on the LLVM compiler framework targeting unmodified multithreaded applications. Our evaluation using Phoenix, PARSEC, and RIPE benchmark suites shows that SGXBounds has performance and memory overheads of 18% and 0.1% respectively, while providing security guarantees similar to AddressSanitizer and Intel MPX. We have obtained similar results with four real-world case studies: SQLite, Memcached, Apache, and Nginx.     FFQ: A Fast Single-Producer/Multiple-Consumer Concurrent FIFO Queue, IPDPS 2017  This paper describes our new lock-free queue for our asynchronous system calls.    Authors : Sergei Arnautov, Pascal Felber, Christof Fetzer and Bohdan Trach    Media :  sorry, not yet available      Abstract :  With the spreading of multi-core architectures, operating systems and applications are becoming increasingly more concurrent and their scalability is often limited by the primitives used to synchronize the different hardware threads. In this paper, we address the problem of how to optimize the throughput of a system with multiple producer and consumer threads. Such applications typically synchronize their threads via multi- producer/multi-consumer FIFO queues, but existing solutions have poor scalability, as we could observe when designing a secure application framework that requires high-throughput communication between many concurrent threads. In our target system, however, the items enqueued by different producers do not necessarily need to be FIFO ordered. Hence, we propose a fast FIFO queue, FFQ, that aims at maximizing throughput by specializing the algorithm for single-producer/multiple-consumer settings: each producer has its own queue from which multiple consumers can concurrently dequeue. Furthermore, while we pro- vide a wait-free interface for producers, we limit ourselves to lock-free consumers to eliminate the need for helping. We also propose a multi-producer variant to show which synchronization operations we were able to remove by focusing on a single producer variant. Our evaluation analyses the performance using micro- benchmarks and compares our results with other state-of-the-art solutions: FFQ exhibits excellent performance and scalability.    Author: Christof Fetzer, 2017",
            "title": "SCONE Related Publications"
        }
    ]
}