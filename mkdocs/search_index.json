{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to SCONE\n\n\nSCONE is a platform to \nbuild and run secure containers\n. Secure containers protect the confidentiality and integrity \nof containers by runing services inside Intel SGX enclaves. For example, we protect services against nosy administrators and hackers with root access that could otherwise just dump the main memory content or configuration files of services to get access to keys stored there. \n\n\nThe secure containers are compatible with Docker containers. SCONE uses Docker Swarm to run and orchestrate \napplications consisting of multiple containers running across multiple hosts. \nWe plan to support other container services - like Kubernetes and Ranger - at some later time.\n\n\nApplication-Oriented Security\n\n\nSCONE supports DevOps to protect the confidentiality and integrity of application even when running in clouds that\ncannot be (completely) trusted. Our approach is to encrypt - by default - all network communication, all files and all \nprocessing (by running inside of enclaves). To reduce the required resources, we support an opt-out approach that\npermits to drop certain protections. For example, a service that operates only on encrypted data might not need to be protected with SGX. \n\n\nEase of Use\n\n\nSCONE supports strong application-oriented security with a workflow like Docker, i.e., \nSCONE supports \nDockerfiles\n as well as extended Docker \nstack\n files. This simplifies the construction and operation of applications consisting of a set of containers. This fits in particular modern cloud-native applications consisting of  microservices and each microservice runs either in a standard or a secure container.\n\n\n\n\nDocumentation\n\n\n\n\n\n\nSCONE Background\n: we give a short introduction regarding the objectives and the problems addressed by SCONE.\n\n\n\n\n\n\nSCONE Host Setup\n: to run secure containers, \nwe need to configure each host to run a Linux SGX driver and also a (for convenience, a patched) Docker engine. \n\n\n\n\n\n\nSCONE SGX Toolchain\n: SCONE supports cross-compilers (C, C++, more to come soon) to compile and build \napplications for SGX enclaves.  \n\n\n\n\n\n\nSCONE Curated Container Images\n: we will support a set of secure container images to simplify the use of  \n\n\n\n\n\n\nSCONE Tutorial\n: we show how to compile simple example applications with the help of the SCONE SGX Toolchain.\n\n\n\n\n\n\nSCONE Dockerfile\n: we support the use of Dockerfiles to generate Docker images that contain services running inside of SGX enclaves (this requires a \npatched Docker Engine\n).\n\n\n\n\n\n\nPublications\n:  some of the technical aspects of SCONE have been published in scientific papers. \nWe provide a short summary of the papers and links to the pdfs. \n\n\n\n\n\n\nAuthor: Christof Fetzer, 2017", 
            "title": "Introduction"
        }, 
        {
            "location": "/#welcome-to-scone", 
            "text": "SCONE is a platform to  build and run secure containers . Secure containers protect the confidentiality and integrity \nof containers by runing services inside Intel SGX enclaves. For example, we protect services against nosy administrators and hackers with root access that could otherwise just dump the main memory content or configuration files of services to get access to keys stored there.   The secure containers are compatible with Docker containers. SCONE uses Docker Swarm to run and orchestrate \napplications consisting of multiple containers running across multiple hosts. \nWe plan to support other container services - like Kubernetes and Ranger - at some later time.", 
            "title": "Welcome to SCONE"
        }, 
        {
            "location": "/#application-oriented-security", 
            "text": "SCONE supports DevOps to protect the confidentiality and integrity of application even when running in clouds that\ncannot be (completely) trusted. Our approach is to encrypt - by default - all network communication, all files and all \nprocessing (by running inside of enclaves). To reduce the required resources, we support an opt-out approach that\npermits to drop certain protections. For example, a service that operates only on encrypted data might not need to be protected with SGX.", 
            "title": "Application-Oriented Security"
        }, 
        {
            "location": "/#ease-of-use", 
            "text": "SCONE supports strong application-oriented security with a workflow like Docker, i.e., \nSCONE supports  Dockerfiles  as well as extended Docker  stack  files. This simplifies the construction and operation of applications consisting of a set of containers. This fits in particular modern cloud-native applications consisting of  microservices and each microservice runs either in a standard or a secure container.", 
            "title": "Ease of Use"
        }, 
        {
            "location": "/#documentation", 
            "text": "SCONE Background : we give a short introduction regarding the objectives and the problems addressed by SCONE.    SCONE Host Setup : to run secure containers, \nwe need to configure each host to run a Linux SGX driver and also a (for convenience, a patched) Docker engine.     SCONE SGX Toolchain : SCONE supports cross-compilers (C, C++, more to come soon) to compile and build \napplications for SGX enclaves.      SCONE Curated Container Images : we will support a set of secure container images to simplify the use of      SCONE Tutorial : we show how to compile simple example applications with the help of the SCONE SGX Toolchain.    SCONE Dockerfile : we support the use of Dockerfiles to generate Docker images that contain services running inside of SGX enclaves (this requires a  patched Docker Engine ).    Publications :  some of the technical aspects of SCONE have been published in scientific papers. \nWe provide a short summary of the papers and links to the pdfs.     Author: Christof Fetzer, 2017", 
            "title": "Documentation"
        }, 
        {
            "location": "/background/", 
            "text": "SCONE Background\n\n\n\n\nApplication-oriented security\n. The objective of SCONE is to help service providers to build secure applications for public, private or hybrid clouds. This means that the focus of SCONE is on application-oriented security and not on the security of the underlying cloud system. Of course, SCONE-based applications benefit from strong security properties of the underlying cloud because this minimizes, for example, the attack surface of SCONE-based applications and by providing higher availability. SCONE helps to ensure the security of an application, i.e., the application's integrity and confidentiality, even if the security of the underlying cloud or system software would be compromised. The security of applications is ensured with the help of Intel SGX enclaves. \n\n\n\n\n\n\n\n\nEase of use\n. SCONE combines strong security with the ease of use of Docker. SCONE supports a workflow very similar to that of Docker. It supports the construction of applications consisting of multiple containers while ensuring end-to-end encryption between all application components in the sense that all network traffic, all files and even all computation is encrypted. A service provider can ensure the confidentiality and integrity of all application data. In particular, SCONE supports the construction of applications such that no higher privileged software like the operating system or the hypervisor, nor any system administrator with root access nor cold boot attacks can gain access to application data.\n\n\n\n\n\n\nProblem: Defender's Dilemma\n\n\nTraditionally, one ensures the security of an application by ensuring that the system software, i.e., the hypervisor, operating system and cloud software is trustworthy. This not only protects the integrity and confidentiality of the system data but also protects the security of the applications. A service provider running applications in the cloud must trust all system software and also all administrators who have root or physical access to these systems.\n\n\nFor an attacker it might be sufficient to exploit a single vulnerability in either the application or the system software to violate the application security. The problem of this approach is that the defenders must protect against the exploitation of every single vulnerability that might exist in the source code. A service provider might not have access to the source code of the system software that the cloud provider uses to operate the cloud. Even if the source code were available, this will typically be too large to be inspected. \n\n\nTo show how large this problem is, let's look at the number of lines of source code of common system software components. While lines of source code is not an ideal  indicator for the number of vulnerabilities, it gives some indication of the problem we are facing. Some security researchers state that given the current state of the art, only code with up to 10,000s of lines of code can be reasonably inspected. Just the system software itself - which all needs to be protected - contains millions of lines of code. This is orders of magnitudes more than we can reasonably expect to be able to inspect.\n\n\nSCONE runs on top of Linux - which contains millions of lines of code and is still growing in size with each release:\n\n\n\n\nLinux Lines of Code (StefanPohl, CC0, \noriginal\n}\n\n\nOpenStack is a popular open source software to manage clouds. OpenStack - despite being relatively young - has been growing dramatically over the years that it has already reached 5 million lines of code (including comments and blank lines):\n\n\n\n\nOpenStack Lines of Code (OpenHub \noriginal\n)\n\n\nTo manage containers, we need an engine like Docker. Docker is younger than OpenStack but has nevertheless reached already more than 180,000 lines of code:\n\n\n\n\nDocker Lines of Code (OpenHub \noriginal\n)\n\n\nCode complexity\n.There is no one-to-one correlation between lines of codes and bugs. Static analysis of open source code repositories indicates approximately 0.61 defects per 1,000 LOC. A recent analysis of Linux shows that, despite an increasing number of defects being fixed, there are always approximately 5,000 defects waiting to be fixed. Not all of these defects can, however, be exploited for security attacks. Another analysis found that approximately 500 security-relevant bugs were fixed in Linux over the past five years - bugs that had been in the kernel for five years before being discovered and fixed. Commercial code had a slightly higher defect density than open source projects. Hence, we need to expect vulnerabilities in commercial software too.\n\n\nSCONE Approach\n\n\nThe approach of SCONE is to reduce the code size by placing only the essential components of an application inside of enclaves. Our underlying assumption is that it is practically to difficult to split existing code base of a single process into component that run inside an enclave and components that run outside of an enclave. However, many modern applications - like cloud-native applications - are already split in several components running in separate address spaces. These components are typically microservices. \n\n\nOne can build even critical applications with the help of microservices. Not all microservices of an application need to run in enclaves to protect the application\u2019s integrity and confidentiality. For example, some services might only process encrypted data, like encrypted log data, and do not need to run in enclaves.  Also, the resource manager does not need to run in an enclave either. \n\n\nThe use of microservices supports horizontal scalability. This helps to cope with limited EPC (extended page cache) by spreading secure microservices across different CPUs.\n\n\nAuthor: Christof Fetzer, 2017", 
            "title": "SCONE Background"
        }, 
        {
            "location": "/background/#scone-background", 
            "text": "Application-oriented security . The objective of SCONE is to help service providers to build secure applications for public, private or hybrid clouds. This means that the focus of SCONE is on application-oriented security and not on the security of the underlying cloud system. Of course, SCONE-based applications benefit from strong security properties of the underlying cloud because this minimizes, for example, the attack surface of SCONE-based applications and by providing higher availability. SCONE helps to ensure the security of an application, i.e., the application's integrity and confidentiality, even if the security of the underlying cloud or system software would be compromised. The security of applications is ensured with the help of Intel SGX enclaves.      Ease of use . SCONE combines strong security with the ease of use of Docker. SCONE supports a workflow very similar to that of Docker. It supports the construction of applications consisting of multiple containers while ensuring end-to-end encryption between all application components in the sense that all network traffic, all files and even all computation is encrypted. A service provider can ensure the confidentiality and integrity of all application data. In particular, SCONE supports the construction of applications such that no higher privileged software like the operating system or the hypervisor, nor any system administrator with root access nor cold boot attacks can gain access to application data.", 
            "title": "SCONE Background"
        }, 
        {
            "location": "/background/#problem-defenders-dilemma", 
            "text": "Traditionally, one ensures the security of an application by ensuring that the system software, i.e., the hypervisor, operating system and cloud software is trustworthy. This not only protects the integrity and confidentiality of the system data but also protects the security of the applications. A service provider running applications in the cloud must trust all system software and also all administrators who have root or physical access to these systems.  For an attacker it might be sufficient to exploit a single vulnerability in either the application or the system software to violate the application security. The problem of this approach is that the defenders must protect against the exploitation of every single vulnerability that might exist in the source code. A service provider might not have access to the source code of the system software that the cloud provider uses to operate the cloud. Even if the source code were available, this will typically be too large to be inspected.   To show how large this problem is, let's look at the number of lines of source code of common system software components. While lines of source code is not an ideal  indicator for the number of vulnerabilities, it gives some indication of the problem we are facing. Some security researchers state that given the current state of the art, only code with up to 10,000s of lines of code can be reasonably inspected. Just the system software itself - which all needs to be protected - contains millions of lines of code. This is orders of magnitudes more than we can reasonably expect to be able to inspect.  SCONE runs on top of Linux - which contains millions of lines of code and is still growing in size with each release:   Linux Lines of Code (StefanPohl, CC0,  original }  OpenStack is a popular open source software to manage clouds. OpenStack - despite being relatively young - has been growing dramatically over the years that it has already reached 5 million lines of code (including comments and blank lines):   OpenStack Lines of Code (OpenHub  original )  To manage containers, we need an engine like Docker. Docker is younger than OpenStack but has nevertheless reached already more than 180,000 lines of code:   Docker Lines of Code (OpenHub  original )  Code complexity .There is no one-to-one correlation between lines of codes and bugs. Static analysis of open source code repositories indicates approximately 0.61 defects per 1,000 LOC. A recent analysis of Linux shows that, despite an increasing number of defects being fixed, there are always approximately 5,000 defects waiting to be fixed. Not all of these defects can, however, be exploited for security attacks. Another analysis found that approximately 500 security-relevant bugs were fixed in Linux over the past five years - bugs that had been in the kernel for five years before being discovered and fixed. Commercial code had a slightly higher defect density than open source projects. Hence, we need to expect vulnerabilities in commercial software too.", 
            "title": "Problem: Defender's Dilemma"
        }, 
        {
            "location": "/background/#scone-approach", 
            "text": "The approach of SCONE is to reduce the code size by placing only the essential components of an application inside of enclaves. Our underlying assumption is that it is practically to difficult to split existing code base of a single process into component that run inside an enclave and components that run outside of an enclave. However, many modern applications - like cloud-native applications - are already split in several components running in separate address spaces. These components are typically microservices.   One can build even critical applications with the help of microservices. Not all microservices of an application need to run in enclaves to protect the application\u2019s integrity and confidentiality. For example, some services might only process encrypted data, like encrypted log data, and do not need to run in enclaves.  Also, the resource manager does not need to run in an enclave either.   The use of microservices supports horizontal scalability. This helps to cope with limited EPC (extended page cache) by spreading secure microservices across different CPUs.  Author: Christof Fetzer, 2017", 
            "title": "SCONE Approach"
        }, 
        {
            "location": "/SCONE_HOSTINSTALLER_README/", 
            "text": "SCONE: Host Installation Guide\n\n\nThis documentation describes how \n\n\n\n\nto set up a host such that it can run SCONE secure containers, i.e., containers in which processes run inside of SGX enclaves,\n\n\n\n\nThe installation script\n\n\n\n\n\n\ninstalls the Intel SGX drive (if it is not yet installed), and\n\n\n\n\n\n\ninstalls a patched docker engine (if it is not yet installed).\n\n\n\n\n\n\nPrerequisite\n:  We assume that you have Ubuntu 16.04LTS (or later) installed. \n\n\nSCONE Documentation\n\n\nTo read more about our SCONE secure container framework, please ensure that docker is installed and then execute the following:\n\n\ndocker pull sconecuratedimages/sconedocu\ndocker run -d -p 8080:80  sconecuratedimages/sconedocu\nopen http://127.0.0.1:8080\n\n\n\n\nPatched Docker Engine\n\n\nFor an container to be able to use SGX, it has to have access to a device (/dev/isgx). This device permits the container to talk to the SGX driver, e.g., to create SGX enclaves. Some docker commands (like \ndocker run\n) support an option --device (i.e., \n--device /dev/isgx\n) which allows us to give a container access to the SGX device. We need to point out that some docker commands (like \ndocker build\n) do, however, not support the device option. Therefore, we maintain and install a slightly patched docker engine (i.e., a variant of moby): this engine ensures that each container has access to the SGX device (/dev/isgx).  With the help of this patched engine, we can use Dockerfiles to generate container images (see this \nTutorial\n).\n\n\nThe installation is performed with the help of Debian packages hosted on https://sconecontainers.github.io/. Details of the installations are \n\n\nIn case you have already a docker engine installed and want to install the patched engine, please remove the installed engine first manually:\n\n\nsudo apt-get remove docker-engine\n\n\n\n\nIf you have a new installation, you might have \ndocker-ce\n installed. In this case, execute the following:\n\n\nsudo apt-get remove docker-ce\n\n\n\n\nInstallation\n\n\nTo install all necessary software to run secure containers on a host, clone the script:\n\n\ngit clone https://github.com/christoffetzer/SCONE_HOSTINSTALLER.git\n\n\n\n\nensure that you are permitted to execute sudo and execute the following command:\n\n\ncd SCONE_HOSTINSTALLER; sudo ./install.sh\n\n\n\n\nThe script should output 'OK' on success.\n\n\nChecking your Installation\n\n\nTo test the installation, one can run a simple hello-world container:\n\n\nsudo docker run hello-world\n\n\n\n\nFuture Work\n\n\n\n\nwe plan to support hosts managed by Ubuntu MaaS to simplify the process of installing Docker and DockerSwarm. \nWe plan to provide a preconfigured SCONE host images for MaaS - as soon as custom MaaS images are supported (again).\n\n\n\n\nAuthor: Christof Fetzer, 2017", 
            "title": "SCONE Host Setup"
        }, 
        {
            "location": "/SCONE_HOSTINSTALLER_README/#scone-host-installation-guide", 
            "text": "This documentation describes how    to set up a host such that it can run SCONE secure containers, i.e., containers in which processes run inside of SGX enclaves,   The installation script    installs the Intel SGX drive (if it is not yet installed), and    installs a patched docker engine (if it is not yet installed).    Prerequisite :  We assume that you have Ubuntu 16.04LTS (or later) installed.", 
            "title": "SCONE: Host Installation Guide"
        }, 
        {
            "location": "/SCONE_HOSTINSTALLER_README/#scone-documentation", 
            "text": "To read more about our SCONE secure container framework, please ensure that docker is installed and then execute the following:  docker pull sconecuratedimages/sconedocu\ndocker run -d -p 8080:80  sconecuratedimages/sconedocu\nopen http://127.0.0.1:8080", 
            "title": "SCONE Documentation"
        }, 
        {
            "location": "/SCONE_HOSTINSTALLER_README/#patched-docker-engine", 
            "text": "For an container to be able to use SGX, it has to have access to a device (/dev/isgx). This device permits the container to talk to the SGX driver, e.g., to create SGX enclaves. Some docker commands (like  docker run ) support an option --device (i.e.,  --device /dev/isgx ) which allows us to give a container access to the SGX device. We need to point out that some docker commands (like  docker build ) do, however, not support the device option. Therefore, we maintain and install a slightly patched docker engine (i.e., a variant of moby): this engine ensures that each container has access to the SGX device (/dev/isgx).  With the help of this patched engine, we can use Dockerfiles to generate container images (see this  Tutorial ).  The installation is performed with the help of Debian packages hosted on https://sconecontainers.github.io/. Details of the installations are   In case you have already a docker engine installed and want to install the patched engine, please remove the installed engine first manually:  sudo apt-get remove docker-engine  If you have a new installation, you might have  docker-ce  installed. In this case, execute the following:  sudo apt-get remove docker-ce", 
            "title": "Patched Docker Engine"
        }, 
        {
            "location": "/SCONE_HOSTINSTALLER_README/#installation", 
            "text": "To install all necessary software to run secure containers on a host, clone the script:  git clone https://github.com/christoffetzer/SCONE_HOSTINSTALLER.git  ensure that you are permitted to execute sudo and execute the following command:  cd SCONE_HOSTINSTALLER; sudo ./install.sh  The script should output 'OK' on success.", 
            "title": "Installation"
        }, 
        {
            "location": "/SCONE_HOSTINSTALLER_README/#checking-your-installation", 
            "text": "To test the installation, one can run a simple hello-world container:  sudo docker run hello-world", 
            "title": "Checking your Installation"
        }, 
        {
            "location": "/SCONE_HOSTINSTALLER_README/#future-work", 
            "text": "we plan to support hosts managed by Ubuntu MaaS to simplify the process of installing Docker and DockerSwarm. \nWe plan to provide a preconfigured SCONE host images for MaaS - as soon as custom MaaS images are supported (again).   Author: Christof Fetzer, 2017", 
            "title": "Future Work"
        }, 
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/", 
            "text": "SCONE SGX Toolchain\n\n\nSCONE comes with cross-compilers for popular languages: C, C++, GO, Rust as well as Fortran.\nThe objective of these cross compilers are to compile applications - generally without source code changes - such\nthat they can run inside of SGX enclaves.\n\n\nTo simplify the use of these cross-compilers, SCONE maintains curated container image that includes these cross-compilers.\n\n\nUsing the C/C++ compiler container\n\n\nHow to use the compiler:\n\n\n\n\n\n\nuse this as a base image and build your programs inside of a container (see \nDockerfiles\n), or \n\n\n\n\n\n\nmap volumes such that the compiler can compile files living outside the container (see \nSCONE Tutorial\n). This is probably only practical for small projects.\n\n\n\n\n\n\nExample\n\n\nOne can use the compiler by giving it access to external files as follows:\n\n\ndocker run --rm --device=/dev/isgx -v \n$PWD\n:/usr/src/myapp -w /usr/src/myapp sgxmusl:draft sgxmusl-hw-async-gcc /usr/src/myapp/myapp.c\n\n\n\n\nSee our \nhello world\n in Section \nSCONE Tutorial\n. This is kind of awkward and hence, we\nprovide a simpler version with the help of \nDockerfiles\n. \n\n\nCompiler variants\n\n\nThe SCONE SGX toolchain supports multiple C and C++ cross compilers variants. In future, we will probably only support a single variant. Hence, we recommend the use of the cross compiler as shown in \nDockerfiles\n.\n\n\nCurrently, the SCONE SGX toolchain supports the following variants of C and C++ cross compilers:\n\n\n\n\n\n\nhw-async\n: generates enclaved programs that use the SCONE asynchronous system call interface, i.e., threads do not exit the enclave to execute a system call. For a technical explanation see [SCONE paper in OSDI2016]. \n\n\n\n\n\n\nhw-shielded\n: this variant based on \nhw-async\n that additionally supports transparent file protection (i.e., transparent encryption von files) and transparent socket protection (i.e., encryption via TLS).  \n\n\n\n\n\n\nhw-sync\n [measurements only]: this variant uses synchronous system calls, i.e., threads leave the enclave to perform a system call. We maintain this variant for measurement purposes only and we recommend to use \nhw-async\n instead.\n\n\n\n\n\n\nsim\n [SCONE development only]: does not need SGX CPU extension and can, for example, be used to develop on machines without SGX support. This is not 100% compatible to \nhw-async\n (yet) and hence, do not use this variant - unless you are aware that the limitations are ok for you.\n\n\n\n\n\n\nsim-shielded\n [SCONE development only]: this variant based on \nsim\n that additionally supports transparent file protection (i.e., transparent encryption von files) and transparent socket protection (i.e., encryption via TLS).  \n\n\n\n\n\n\nDebugger support\n\n\nWe also support \ngdb\n to debug applications running inside of enclaves. \n\n\nFuture work\n\n\n\n\ndescribe the use of the debugger.\n\n\n\n\nAuthor: Christof Fetzer, 2017", 
            "title": "SCONE SGX toolchain"
        }, 
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/#scone-sgx-toolchain", 
            "text": "SCONE comes with cross-compilers for popular languages: C, C++, GO, Rust as well as Fortran.\nThe objective of these cross compilers are to compile applications - generally without source code changes - such\nthat they can run inside of SGX enclaves.  To simplify the use of these cross-compilers, SCONE maintains curated container image that includes these cross-compilers.", 
            "title": "SCONE SGX Toolchain"
        }, 
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/#using-the-cc-compiler-container", 
            "text": "How to use the compiler:    use this as a base image and build your programs inside of a container (see  Dockerfiles ), or     map volumes such that the compiler can compile files living outside the container (see  SCONE Tutorial ). This is probably only practical for small projects.", 
            "title": "Using the C/C++ compiler container"
        }, 
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/#example", 
            "text": "One can use the compiler by giving it access to external files as follows:  docker run --rm --device=/dev/isgx -v  $PWD :/usr/src/myapp -w /usr/src/myapp sgxmusl:draft sgxmusl-hw-async-gcc /usr/src/myapp/myapp.c  See our  hello world  in Section  SCONE Tutorial . This is kind of awkward and hence, we\nprovide a simpler version with the help of  Dockerfiles .", 
            "title": "Example"
        }, 
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/#compiler-variants", 
            "text": "The SCONE SGX toolchain supports multiple C and C++ cross compilers variants. In future, we will probably only support a single variant. Hence, we recommend the use of the cross compiler as shown in  Dockerfiles .  Currently, the SCONE SGX toolchain supports the following variants of C and C++ cross compilers:    hw-async : generates enclaved programs that use the SCONE asynchronous system call interface, i.e., threads do not exit the enclave to execute a system call. For a technical explanation see [SCONE paper in OSDI2016].     hw-shielded : this variant based on  hw-async  that additionally supports transparent file protection (i.e., transparent encryption von files) and transparent socket protection (i.e., encryption via TLS).      hw-sync  [measurements only]: this variant uses synchronous system calls, i.e., threads leave the enclave to perform a system call. We maintain this variant for measurement purposes only and we recommend to use  hw-async  instead.    sim  [SCONE development only]: does not need SGX CPU extension and can, for example, be used to develop on machines without SGX support. This is not 100% compatible to  hw-async  (yet) and hence, do not use this variant - unless you are aware that the limitations are ok for you.    sim-shielded  [SCONE development only]: this variant based on  sim  that additionally supports transparent file protection (i.e., transparent encryption von files) and transparent socket protection (i.e., encryption via TLS).", 
            "title": "Compiler variants"
        }, 
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/#debugger-support", 
            "text": "We also support  gdb  to debug applications running inside of enclaves.", 
            "title": "Debugger support"
        }, 
        {
            "location": "/SCONE_COMPILER_CONTAINER_README/#future-work", 
            "text": "describe the use of the debugger.   Author: Christof Fetzer, 2017", 
            "title": "Future work"
        }, 
        {
            "location": "/SCONE_Curated_Images/", 
            "text": "SCONE Curated Images\n\n\nWe provide a set of curated SCONE container images on a (private) repositories on Docker hub:\n\n\n\n\nsconecuratedimages/sconedocu\n: contains containers related to our SCONE documentation \n\n\nsconecuratedimages/crosscompilers\n: contains container images of the SCONE cross compilers \n\n\nsconecuratedimages/tutorial\n: contains containers related to our SCONE tutorial \n\n\n\n\nScone Documentation\n\n\nTo run a local copy of the SCONE documentation, just perform the following steps:\n\n\ndocker pull sconecuratedimages/sconedocu\ndocker run -d -p 8080:80  sconecuratedimages/sconedocu\n\n\n\n\nView the documentation in your browser at http://127.0.0.1:8080 .\nOn a MAC, just type:\n\n\nopen http://127.0.0.1:8080\n\n\n\n\nto view this docu.\n\n\nLogin in\n\n\nAccess to some SCONE images is still restricted. First, get access\nto the images by sending email to scone.containers@gmail.com. \nSecond, log into to docker hub via:\n\n\ndocker login\n\n\n\n\nbefore you pull any of the curated images.\n\n\nScone Cross-Compilers\n\n\nTo run a local copy of the SCONE cross compilers, just pull the appropriate image on your computer.\n\n\nIn case you do not have SGX CPU extension / no SGX driver installed on your computer,\nyou can use our simulation environment. This runs the SCONE software but provides \nno protection\nof the confidentiality nor integrity\n of your application:\n\n\nsudo docker pull sconecuratedimages/crosscompilers:gcc-sim\n\n\n\n\nTo install our standard scone C / C++ cross compiler, just perform the following\nsteps.\n\n\nsudo docker pull sconecuratedimages/crosscompilers\n\n\n\n\nScone Hello World\n\n\nYou can pull the following image:\n\n\nsudo docker pull sconecuratedimages/helloworld\n\n\n\n\nand run the helloworld program inside of an enclave via\n\n\n sudo docker run --device=/dev/isgx sconecuratedimages/helloworld\nHello World\n\n\n\n\nthis will fail, in case you do not provide the container with the sgx device:\n\n\n sudo docker run sconecuratedimages/helloworld\nerror opening sgx device: No such file or directory\n\n\n\n\nNote, if you installed the modified Docker Engine that we provide, a container gets\nby default access to device \n/dev/isgx\n, i.e., in this case no error would occur.\n\n\nAuthor: Christof Fetzer, 2017", 
            "title": "SCONE Curated Images"
        }, 
        {
            "location": "/SCONE_Curated_Images/#scone-curated-images", 
            "text": "We provide a set of curated SCONE container images on a (private) repositories on Docker hub:   sconecuratedimages/sconedocu : contains containers related to our SCONE documentation   sconecuratedimages/crosscompilers : contains container images of the SCONE cross compilers   sconecuratedimages/tutorial : contains containers related to our SCONE tutorial", 
            "title": "SCONE Curated Images"
        }, 
        {
            "location": "/SCONE_Curated_Images/#scone-documentation", 
            "text": "To run a local copy of the SCONE documentation, just perform the following steps:  docker pull sconecuratedimages/sconedocu\ndocker run -d -p 8080:80  sconecuratedimages/sconedocu  View the documentation in your browser at http://127.0.0.1:8080 .\nOn a MAC, just type:  open http://127.0.0.1:8080  to view this docu.", 
            "title": "Scone Documentation"
        }, 
        {
            "location": "/SCONE_Curated_Images/#login-in", 
            "text": "Access to some SCONE images is still restricted. First, get access\nto the images by sending email to scone.containers@gmail.com. \nSecond, log into to docker hub via:  docker login  before you pull any of the curated images.", 
            "title": "Login in"
        }, 
        {
            "location": "/SCONE_Curated_Images/#scone-cross-compilers", 
            "text": "To run a local copy of the SCONE cross compilers, just pull the appropriate image on your computer.  In case you do not have SGX CPU extension / no SGX driver installed on your computer,\nyou can use our simulation environment. This runs the SCONE software but provides  no protection\nof the confidentiality nor integrity  of your application:  sudo docker pull sconecuratedimages/crosscompilers:gcc-sim  To install our standard scone C / C++ cross compiler, just perform the following\nsteps.  sudo docker pull sconecuratedimages/crosscompilers", 
            "title": "Scone Cross-Compilers"
        }, 
        {
            "location": "/SCONE_Curated_Images/#scone-hello-world", 
            "text": "You can pull the following image:  sudo docker pull sconecuratedimages/helloworld  and run the helloworld program inside of an enclave via   sudo docker run --device=/dev/isgx sconecuratedimages/helloworld\nHello World  this will fail, in case you do not provide the container with the sgx device:   sudo docker run sconecuratedimages/helloworld\nerror opening sgx device: No such file or directory  Note, if you installed the modified Docker Engine that we provide, a container gets\nby default access to device  /dev/isgx , i.e., in this case no error would occur.  Author: Christof Fetzer, 2017", 
            "title": "Scone Hello World"
        }, 
        {
            "location": "/SCONE_TUTORIAL/", 
            "text": "SCONE Tutorial\n\n\nPrerequisites\n\n\nEnsure that the sgx driver is installed\n\n\n ls /dev/isgx \n/dev/isgx\n\n\n\n\nIf the driver is not installed, read Section \nSCONE Host Setup\n to learn how to install the SGX driver.\n\n\nInstall sgxmusl cross compiler image\n\n\nEnsure that you installed the sgxmusl:draft container image:\n\n\n docker image ls sconecuratedimages/crosscompilers\nREPOSITORY                          TAG                 IMAGE ID            CREATED             SIZE\nsconecuratedimages/crosscompilers   gcc-sim             e5cabb3682d6        17 hours ago        1.18 GB\nsconecuratedimages/crosscompilers   gcc-sync            a4768b000fcc        18 hours ago        1.18 GB\n\n\n\n\nIf the cross compiler image is not yet installed, read Section \nSCONE Curated Container Images\n to learn how to install the SCONE cross compiler image.\n\n\nInstall the tutorial\n\n\nClone the tutorial: \n\n\ngit clone https://github.com/christoffetzer/SCONE_TUTORIAL.git\n\n\n\n\nNative Hello World\n\n\nEnsure that \nhello world\n runs natively on your machine:\n\n\ncd SCONE_TUTORIAL/HelloWorld/\ngcc hello_world.c  -o native_hello_world\n./native_hello_world\nHello World\n\n\n\n\nSIM Hello World\n\n\nNow, let us compile \nhello world\n with the help of a cross compiler image that creates binaries that include all SCONE software \nbut the services run actually outside of enclave. We call this variant \nsim\n and made available in image \nsconecuratedimages/crosscompilers:gcc-sim\n\nthat you can pull from docker hub.\n\n\nThe sim variant simplifies debugging. \nsim\n is, however, not 100% identical with the \nasync\n branch (i.e., the recommended branch to run applications inside of enclaves).\nHence, debugging using \nsim\n might not be possible for all bugs. \n\n\nsudo docker run --rm -v \n$PWD\n:/usr/src/myapp -w /usr/src/myapp sconecuratedimages/crosscompilers:gcc-sim sgxmusl-sim-gcc /usr/src/myapp/hello_world.c  -o sim_hello_world\n./sim_hello_world\nHello World\n\n\n\n\nNote that the generated executable, i.e., \nsim_hello_world\n, will only run on Linux. \n\n\nSGX ASYNC Hello World\n\n\nThe default cross compiler variant that runs \nhello world\n inside of an enclave is \nsgxmusl-hw-async-gcc\n and you can find this in container \nsconecuratedimages/crosscompilers\n. \nThis variant requires access to the SGX device. \nIn Linux, the SGX device is made available as \n/dev/isgx\n and we can give the cross compiler inside of an container access via option \n--device=/dev/isgx\n:\n\n\nsudo docker run --rm --device=/dev/isgx -v \n$PWD\n:/usr/src/myapp -w /usr/src/myapp sconecuratedimages/crosscompilers sgxmusl-hw-async-gcc /usr/src/myapp/hello_world.c  -o sgx_hello_world\n./sgx_hello_world\nHello World\n\n\n\n\nThe compilation as well as the hello world program will fail in case you do not have the appropriate driver installed.\n\n\nRun STRACE\n\n\nLets see how we can trace the program. Say, you have compile the program as shown above. After that you enter a cross compiler container and strace hello world as follows:\n\n\nsudo docker run --cap-add SYS_PTRACE -it --rm --device=/dev/isgx -v \n$PWD\n:/usr/src/myapp -w /usr/src/myapp sconecuratedimages/crosscompilers bash\nstrace  -f /usr/src/myapp/sgx_sync_hello_world\n\n\n\n\nRun ShellScript\n\n\nAuthor: Christof Fetzer, April 2017", 
            "title": "SCONE Tutorial"
        }, 
        {
            "location": "/SCONE_TUTORIAL/#scone-tutorial", 
            "text": "", 
            "title": "SCONE Tutorial"
        }, 
        {
            "location": "/SCONE_TUTORIAL/#prerequisites", 
            "text": "", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/SCONE_TUTORIAL/#ensure-that-the-sgx-driver-is-installed", 
            "text": "ls /dev/isgx \n/dev/isgx  If the driver is not installed, read Section  SCONE Host Setup  to learn how to install the SGX driver.", 
            "title": "Ensure that the sgx driver is installed"
        }, 
        {
            "location": "/SCONE_TUTORIAL/#install-sgxmusl-cross-compiler-image", 
            "text": "Ensure that you installed the sgxmusl:draft container image:   docker image ls sconecuratedimages/crosscompilers\nREPOSITORY                          TAG                 IMAGE ID            CREATED             SIZE\nsconecuratedimages/crosscompilers   gcc-sim             e5cabb3682d6        17 hours ago        1.18 GB\nsconecuratedimages/crosscompilers   gcc-sync            a4768b000fcc        18 hours ago        1.18 GB  If the cross compiler image is not yet installed, read Section  SCONE Curated Container Images  to learn how to install the SCONE cross compiler image.", 
            "title": "Install sgxmusl cross compiler image"
        }, 
        {
            "location": "/SCONE_TUTORIAL/#install-the-tutorial", 
            "text": "Clone the tutorial:   git clone https://github.com/christoffetzer/SCONE_TUTORIAL.git", 
            "title": "Install the tutorial"
        }, 
        {
            "location": "/SCONE_TUTORIAL/#native-hello-world", 
            "text": "Ensure that  hello world  runs natively on your machine:  cd SCONE_TUTORIAL/HelloWorld/\ngcc hello_world.c  -o native_hello_world\n./native_hello_world\nHello World", 
            "title": "Native Hello World"
        }, 
        {
            "location": "/SCONE_TUTORIAL/#sim-hello-world", 
            "text": "Now, let us compile  hello world  with the help of a cross compiler image that creates binaries that include all SCONE software \nbut the services run actually outside of enclave. We call this variant  sim  and made available in image  sconecuratedimages/crosscompilers:gcc-sim \nthat you can pull from docker hub.  The sim variant simplifies debugging.  sim  is, however, not 100% identical with the  async  branch (i.e., the recommended branch to run applications inside of enclaves).\nHence, debugging using  sim  might not be possible for all bugs.   sudo docker run --rm -v  $PWD :/usr/src/myapp -w /usr/src/myapp sconecuratedimages/crosscompilers:gcc-sim sgxmusl-sim-gcc /usr/src/myapp/hello_world.c  -o sim_hello_world\n./sim_hello_world\nHello World  Note that the generated executable, i.e.,  sim_hello_world , will only run on Linux.", 
            "title": "SIM Hello World"
        }, 
        {
            "location": "/SCONE_TUTORIAL/#sgx-async-hello-world", 
            "text": "The default cross compiler variant that runs  hello world  inside of an enclave is  sgxmusl-hw-async-gcc  and you can find this in container  sconecuratedimages/crosscompilers . \nThis variant requires access to the SGX device. \nIn Linux, the SGX device is made available as  /dev/isgx  and we can give the cross compiler inside of an container access via option  --device=/dev/isgx :  sudo docker run --rm --device=/dev/isgx -v  $PWD :/usr/src/myapp -w /usr/src/myapp sconecuratedimages/crosscompilers sgxmusl-hw-async-gcc /usr/src/myapp/hello_world.c  -o sgx_hello_world\n./sgx_hello_world\nHello World  The compilation as well as the hello world program will fail in case you do not have the appropriate driver installed.", 
            "title": "SGX ASYNC Hello World"
        }, 
        {
            "location": "/SCONE_TUTORIAL/#run-strace", 
            "text": "Lets see how we can trace the program. Say, you have compile the program as shown above. After that you enter a cross compiler container and strace hello world as follows:  sudo docker run --cap-add SYS_PTRACE -it --rm --device=/dev/isgx -v  $PWD :/usr/src/myapp -w /usr/src/myapp sconecuratedimages/crosscompilers bash\nstrace  -f /usr/src/myapp/sgx_sync_hello_world", 
            "title": "Run STRACE"
        }, 
        {
            "location": "/SCONE_TUTORIAL/#run-shellscript", 
            "text": "Author: Christof Fetzer, April 2017", 
            "title": "Run ShellScript"
        }, 
        {
            "location": "/SCONE_GENERATE_IMAGE/", 
            "text": "Generating Container Image with SCONE\n\n\nWe show how to generate a Docker image that contains our \nhello world\n running inside of an enclave and pushing this to docker hub. We show this \n\n\nPrerequisites\n\n\nCheck that all prerequisites from \nSCONE Tutorial\n are satisfied. \nClone the SCONE_TUTORIAL before you start creating a \nhello world\n image.\n\n\nGenerate HelloWorld image\n\n\nWe generate a \nhello world\n container image. \n\n\ncd SCONE_TUTORIAL/CreateImage\n\n\n\n\nYou can either execute all step manually by copy\npasting all instructions or you can just execute\n\n\ndocker login\nsudo ./Dockerfile.sh\n\n\n\n\nand watch the outputs.\n\n\nPlease change the image name to a repository on docker hub to which you can write:\n\n\nexport TAG=\nlatest\n\nexport IMAGE_NAME=\nsconecuratedimages/helloworld\n\n\n\n\n\nWe generate container and compile hello world inside of this container with the help of our standard SCONE cross compiler:\n\n\n\nCONTAINER_ID=`docker run -d -it --device=/dev/isgx  -v $(pwd):/mnt sconecuratedimages/crosscompilers bash -c \n\nset -e\nsgxmusl-hw-async-gcc /mnt/hello_world.c  -o /usr/local/bin/sgx_hello_world\n\n`\n\n\n\n\nNote that above will fail if you do not have access to the SGX device \n/dev/isgx\n.\n\n\nTurn the container into an image:\n\n\nIMAGE_ID=$(docker commit -p -c 'CMD sgx_hello_world' $CONTAINER_ID $IMAGE_NAME:$TAG)\n\n\n\n\nYou can run this image by executing:\n\n\nsudo docker run --device=/dev/isgx $IMAGE_NAME:$TAG\n\n\n\n\nYou can push this image to Docker. However, ensure that you first login to docker:\n\n\nsudo docker login\n\n\n\n\nbefore you push the image to docker hub:\n\n\nsudo docker push $IMAGE_NAME:$TAG\n\n\n\n\nNote: this will fail in case you do not have the permission to push to this repository. \n\n\nAuthor: Christof Fetzer, April 2017", 
            "title": "SCONE Create Image"
        }, 
        {
            "location": "/SCONE_GENERATE_IMAGE/#generating-container-image-with-scone", 
            "text": "We show how to generate a Docker image that contains our  hello world  running inside of an enclave and pushing this to docker hub. We show this", 
            "title": "Generating Container Image with SCONE"
        }, 
        {
            "location": "/SCONE_GENERATE_IMAGE/#prerequisites", 
            "text": "Check that all prerequisites from  SCONE Tutorial  are satisfied. \nClone the SCONE_TUTORIAL before you start creating a  hello world  image.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/SCONE_GENERATE_IMAGE/#generate-helloworld-image", 
            "text": "We generate a  hello world  container image.   cd SCONE_TUTORIAL/CreateImage  You can either execute all step manually by copy pasting all instructions or you can just execute  docker login\nsudo ./Dockerfile.sh  and watch the outputs.  Please change the image name to a repository on docker hub to which you can write:  export TAG= latest \nexport IMAGE_NAME= sconecuratedimages/helloworld   We generate container and compile hello world inside of this container with the help of our standard SCONE cross compiler:  \nCONTAINER_ID=`docker run -d -it --device=/dev/isgx  -v $(pwd):/mnt sconecuratedimages/crosscompilers bash -c  \nset -e\nsgxmusl-hw-async-gcc /mnt/hello_world.c  -o /usr/local/bin/sgx_hello_world `  Note that above will fail if you do not have access to the SGX device  /dev/isgx .  Turn the container into an image:  IMAGE_ID=$(docker commit -p -c 'CMD sgx_hello_world' $CONTAINER_ID $IMAGE_NAME:$TAG)  You can run this image by executing:  sudo docker run --device=/dev/isgx $IMAGE_NAME:$TAG  You can push this image to Docker. However, ensure that you first login to docker:  sudo docker login  before you push the image to docker hub:  sudo docker push $IMAGE_NAME:$TAG  Note: this will fail in case you do not have the permission to push to this repository.   Author: Christof Fetzer, April 2017", 
            "title": "Generate HelloWorld image"
        }, 
        {
            "location": "/SCONE_Dockerfile/", 
            "text": "Dockerfile\n\n\nWe show how to generate a Docker image with the help of a Dockerfile.\n\n\nPrerequisites\n\n\nEnsure that the sgx driver is installed\n\n\n ls /dev/isgx \n/dev/isgx\n\n\n\n\nIf the driver is not installed, read Section \nSCONE Host Setup\n to learn how to install the SGX driver.\n\n\nEnsure that the patched docker engine is installed\n\n\nWe need \ndocker build\n in this example. This command does not permit to map devices in the newly created containers. Hence, we provide a patched Docker engine \nSCONE Host Setup\n.\n\n\nInstall the tutorial\n\n\nClone the tutorial: \n\n\ngit clone https://github.com/christoffetzer/SCONE_TUTORIAL.git\n\n\n\n\nGenerate HelloAgain image\n\n\nWe generate a \nhello agsin\n container image. \n\n\ncd SCONE_TUTORIAL/Dockerfile\n\n\n\n\nThe Dockerfile looks, feels like a standard docker image:\n\n\nFROM sconecuratedimages/crosscompilers:sgxmusl-hw-async-gcc\n\nMAINTAINER Christof Fetzer \nchristof.fetzer@gmail.com\n\n\nRUN mkdir /hello\n\nCOPY hello_again.c /hello/\n\nRUN cd /hello \n gcc hello_again.c -o again\n\nCMD [\n/hello/again\n]\n\n\n\n\nYou can either execute all step manually (see below) or you can just execute\n\n\ndocker login\n./generate.sh\n\n\n\n\nand watch the outputs. The push of the image should fail since you should not have the access rights to push the image to Docker hub.\n\n\nWe define the image name and tag that we want to generate:\n\n\nexport TAG=\nagain\n\nexport FULLTAG=\nsconecuratedimages/helloworld:$TAG\n\n\n\n\n\nWe build the image:\n\n\ndocker build --pull -t $FULLTAG .\n\n\n\n\nWe push it to docker hub (will fail unless you have the right to push \n$FULLTAG\n):\n\n\ndocker push $FULLTAG\n\n\n\n\nPlease change the image name to a repository on docker hub to which you can write:\n\n\nexport TAG=\nlatest\n\nexport IMAGE_NAME=\nsconecuratedimages/helloAgain\n\n\n\n\n\nAuthor: Christof Fetzer, 2017", 
            "title": "SCONE Dockerfile"
        }, 
        {
            "location": "/SCONE_Dockerfile/#dockerfile", 
            "text": "We show how to generate a Docker image with the help of a Dockerfile.", 
            "title": "Dockerfile"
        }, 
        {
            "location": "/SCONE_Dockerfile/#prerequisites", 
            "text": "", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/SCONE_Dockerfile/#ensure-that-the-sgx-driver-is-installed", 
            "text": "ls /dev/isgx \n/dev/isgx  If the driver is not installed, read Section  SCONE Host Setup  to learn how to install the SGX driver.", 
            "title": "Ensure that the sgx driver is installed"
        }, 
        {
            "location": "/SCONE_Dockerfile/#ensure-that-the-patched-docker-engine-is-installed", 
            "text": "We need  docker build  in this example. This command does not permit to map devices in the newly created containers. Hence, we provide a patched Docker engine  SCONE Host Setup .", 
            "title": "Ensure that the patched docker engine is installed"
        }, 
        {
            "location": "/SCONE_Dockerfile/#install-the-tutorial", 
            "text": "Clone the tutorial:   git clone https://github.com/christoffetzer/SCONE_TUTORIAL.git", 
            "title": "Install the tutorial"
        }, 
        {
            "location": "/SCONE_Dockerfile/#generate-helloagain-image", 
            "text": "We generate a  hello agsin  container image.   cd SCONE_TUTORIAL/Dockerfile  The Dockerfile looks, feels like a standard docker image:  FROM sconecuratedimages/crosscompilers:sgxmusl-hw-async-gcc\n\nMAINTAINER Christof Fetzer  christof.fetzer@gmail.com \n\nRUN mkdir /hello\n\nCOPY hello_again.c /hello/\n\nRUN cd /hello   gcc hello_again.c -o again\n\nCMD [ /hello/again ]  You can either execute all step manually (see below) or you can just execute  docker login\n./generate.sh  and watch the outputs. The push of the image should fail since you should not have the access rights to push the image to Docker hub.  We define the image name and tag that we want to generate:  export TAG= again \nexport FULLTAG= sconecuratedimages/helloworld:$TAG   We build the image:  docker build --pull -t $FULLTAG .  We push it to docker hub (will fail unless you have the right to push  $FULLTAG ):  docker push $FULLTAG  Please change the image name to a repository on docker hub to which you can write:  export TAG= latest \nexport IMAGE_NAME= sconecuratedimages/helloAgain   Author: Christof Fetzer, 2017", 
            "title": "Generate HelloAgain image"
        }, 
        {
            "location": "/SCONE_Publications/", 
            "text": "SCONE Related Publications\n\n\nSCONE: Secure Linux Containers with Intel SGX, USENIX, OSDI 2016\n\n\nThis paper describes how we support unmodified applications inside of enclaves. The focus is on our asynchronous system\n call interface.\n\n\n\n\n\n\nAuthors\n:  Sergei Arnautov, Bohdan Trach, Franz Gregor, Thomas Knauth, Andr\u00e9 Martin, Christian Priebe, Joshua Lind, Divya Muthukumaran, Daniel O'Keeffe, Mark L Stillwell, David Goltzsche, Dave Eyers, R\u00fcdiger Kapitza, Peter Pietzuch, Christof Fetzer\n\n\n\n\n\n\nMedia\n: \npdf\n, \nslides\n\n\naudio\n\n\n\n\n\n\nAbstract\n:  In multi-tenant environments, Linux containers managed by Docker or Kubernetes have a lower resource footprint, faster startup times, and higher I/O performance compared to virtual machines (VMs) on hypervisors. Yet their weaker isolation guarantees, enforced through software kernel mechanisms, make it easier for attackers to compromise the confidentiality and integrity of application data within containers.\nWe describe SCONE, a secure container mechanism for Docker that uses the SGX trusted execution support of Intel CPUs to protect container processes from outside attacks. The design of SCONE leads to (i) a small trusted computing base (TCB) and (ii) a low performance overhead: SCONE offers a secure C standard library interface that transparently encrypts/decrypts I/O data; to reduce the performance impact of thread synchronization and system calls within SGX enclaves, SCONE supports user-level threading and asynchronous system calls. Our evaluation shows that it protects unmodified applications with SGX, achieving 0.6x\u20131.2x of native throughput.\n\n\n\n\n\n\n SGXBounds: Memory Safety for Shielded Execution, EuroSys 2017\n\n\nTo protect the code running inside of an enclave, we implemented a novel bounds checker for enclaves. While we had expected\n to just be able to use MPX, we had to realized that MPX does not perform that well inside of enclaves. For details regarding\n the overheads,  please see this paper. \nThis won the best paper award of EuroSys 2017.\n\n\n\n\n\n\nAuthors\n: D. Kuvaiskii, O. Oleksenko, S. Arnautov, B. Trach, P. Bhatotia, P. Felber, C. Fetzer \n\n\n\n\n\n\nMedia\n: \npdf\n \n\n\n\n\n\n\nAbstract\n: Shielded execution based on Intel SGX provides strong security guarantees for legacy applications running on untrusted platforms. However, memory safety attacks such as Heartbleed can render the confidentiality and integrity properties of shielded execution completely ineffective. To prevent these attacks, the state-of-the-art memory-safety approaches can be used in the context of shielded execution. In this work, we first showcase that two prominent software- and hardware-based defenses, AddressSanitizer and Intel MPX respectively, are impractical for shielded execution due to high performance and memory overheads. This motivated our design of SGXBounds -- an efficient memory-safety approach for shielded execution exploiting the architectural features of Intel SGX. Our design is based on a simple combination of tagged pointers and compact memory layout. We implemented SGXBounds based on the LLVM compiler framework targeting unmodified multithreaded applications. Our evaluation using Phoenix, PARSEC, and RIPE benchmark suites shows that SGXBounds has performance and memory overheads of 18% and 0.1% respectively, while providing security guarantees similar to AddressSanitizer and Intel MPX. We have obtained similar results with four real-world case studies: SQLite, Memcached, Apache, and Nginx.\n\n\n\n\n\n\n FFQ: A Fast Single-Producer/Multiple-Consumer Concurrent FIFO Queue, IPDPS 2017\n\n\nThis paper describes our new lock-free queue for our asynchronous system calls.\n\n\n\n\n\n\nAuthors\n: Sergei Arnautov, Pascal Felber, Christof Fetzer and Bohdan Trach\n\n\n\n\n\n\nMedia\n: \nsorry, not yet available\n \n\n\n\n\n\n\nAbstract\n:  With the spreading of multi-core architectures, operating systems and applications are becoming increasingly more concurrent and their scalability is often limited by the primitives used to synchronize the different hardware threads. In this paper, we address the problem of how to optimize the throughput of a system with multiple producer and consumer threads. Such applications typically synchronize their threads via multi- producer/multi-consumer FIFO queues, but existing solutions have poor scalability, as we could observe when designing a secure application framework that requires high-throughput communication between many concurrent threads. In our target system, however, the items enqueued by different producers do not necessarily need to be FIFO ordered. Hence, we propose a fast FIFO queue, FFQ, that aims at maximizing throughput by specializing the algorithm for single-producer/multiple-consumer settings: each producer has its own queue from which multiple consumers can concurrently dequeue. Furthermore, while we pro- vide a wait-free interface for producers, we limit ourselves to lock-free consumers to eliminate the need for helping. We also propose a multi-producer variant to show which synchronization operations we were able to remove by focusing on a single producer variant. Our evaluation analyses the performance using micro- benchmarks and compares our results with other state-of-the-art solutions: FFQ exhibits excellent performance and scalability.\n\n\n\n\n\n\nAuthor: Christof Fetzer, January 2017", 
            "title": "SCONE Publications"
        }, 
        {
            "location": "/SCONE_Publications/#scone-related-publications", 
            "text": "SCONE: Secure Linux Containers with Intel SGX, USENIX, OSDI 2016  This paper describes how we support unmodified applications inside of enclaves. The focus is on our asynchronous system\n call interface.    Authors :  Sergei Arnautov, Bohdan Trach, Franz Gregor, Thomas Knauth, Andr\u00e9 Martin, Christian Priebe, Joshua Lind, Divya Muthukumaran, Daniel O'Keeffe, Mark L Stillwell, David Goltzsche, Dave Eyers, R\u00fcdiger Kapitza, Peter Pietzuch, Christof Fetzer    Media :  pdf ,  slides  audio    Abstract :  In multi-tenant environments, Linux containers managed by Docker or Kubernetes have a lower resource footprint, faster startup times, and higher I/O performance compared to virtual machines (VMs) on hypervisors. Yet their weaker isolation guarantees, enforced through software kernel mechanisms, make it easier for attackers to compromise the confidentiality and integrity of application data within containers.\nWe describe SCONE, a secure container mechanism for Docker that uses the SGX trusted execution support of Intel CPUs to protect container processes from outside attacks. The design of SCONE leads to (i) a small trusted computing base (TCB) and (ii) a low performance overhead: SCONE offers a secure C standard library interface that transparently encrypts/decrypts I/O data; to reduce the performance impact of thread synchronization and system calls within SGX enclaves, SCONE supports user-level threading and asynchronous system calls. Our evaluation shows that it protects unmodified applications with SGX, achieving 0.6x\u20131.2x of native throughput.     SGXBounds: Memory Safety for Shielded Execution, EuroSys 2017  To protect the code running inside of an enclave, we implemented a novel bounds checker for enclaves. While we had expected\n to just be able to use MPX, we had to realized that MPX does not perform that well inside of enclaves. For details regarding\n the overheads,  please see this paper.  This won the best paper award of EuroSys 2017.    Authors : D. Kuvaiskii, O. Oleksenko, S. Arnautov, B. Trach, P. Bhatotia, P. Felber, C. Fetzer     Media :  pdf      Abstract : Shielded execution based on Intel SGX provides strong security guarantees for legacy applications running on untrusted platforms. However, memory safety attacks such as Heartbleed can render the confidentiality and integrity properties of shielded execution completely ineffective. To prevent these attacks, the state-of-the-art memory-safety approaches can be used in the context of shielded execution. In this work, we first showcase that two prominent software- and hardware-based defenses, AddressSanitizer and Intel MPX respectively, are impractical for shielded execution due to high performance and memory overheads. This motivated our design of SGXBounds -- an efficient memory-safety approach for shielded execution exploiting the architectural features of Intel SGX. Our design is based on a simple combination of tagged pointers and compact memory layout. We implemented SGXBounds based on the LLVM compiler framework targeting unmodified multithreaded applications. Our evaluation using Phoenix, PARSEC, and RIPE benchmark suites shows that SGXBounds has performance and memory overheads of 18% and 0.1% respectively, while providing security guarantees similar to AddressSanitizer and Intel MPX. We have obtained similar results with four real-world case studies: SQLite, Memcached, Apache, and Nginx.     FFQ: A Fast Single-Producer/Multiple-Consumer Concurrent FIFO Queue, IPDPS 2017  This paper describes our new lock-free queue for our asynchronous system calls.    Authors : Sergei Arnautov, Pascal Felber, Christof Fetzer and Bohdan Trach    Media :  sorry, not yet available      Abstract :  With the spreading of multi-core architectures, operating systems and applications are becoming increasingly more concurrent and their scalability is often limited by the primitives used to synchronize the different hardware threads. In this paper, we address the problem of how to optimize the throughput of a system with multiple producer and consumer threads. Such applications typically synchronize their threads via multi- producer/multi-consumer FIFO queues, but existing solutions have poor scalability, as we could observe when designing a secure application framework that requires high-throughput communication between many concurrent threads. In our target system, however, the items enqueued by different producers do not necessarily need to be FIFO ordered. Hence, we propose a fast FIFO queue, FFQ, that aims at maximizing throughput by specializing the algorithm for single-producer/multiple-consumer settings: each producer has its own queue from which multiple consumers can concurrently dequeue. Furthermore, while we pro- vide a wait-free interface for producers, we limit ourselves to lock-free consumers to eliminate the need for helping. We also propose a multi-producer variant to show which synchronization operations we were able to remove by focusing on a single producer variant. Our evaluation analyses the performance using micro- benchmarks and compares our results with other state-of-the-art solutions: FFQ exhibits excellent performance and scalability.    Author: Christof Fetzer, January 2017", 
            "title": "SCONE Related Publications"
        }
    ]
}